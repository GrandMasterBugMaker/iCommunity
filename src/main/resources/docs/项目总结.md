<!-- TOC -->

- [iCommunity](#icommunity)
  - [功能简介](#功能简介)
  - [主要技术：](#主要技术)
  - [数据库表](#数据库表)
    - [用户表(`user`)](#用户表user)
    - [评论表(`comment`)](#评论表comment)
    - [帖子表(`discuss_post`)](#帖子表discuss_post)
    - [用户登录凭证表(`login_ticket`)](#用户登录凭证表login_ticket)
    - [消息表(`message`)](#消息表message)
  - [开发社区首页](#开发社区首页)
    - [搭建基本环境](#搭建基本环境)
    - [开发社区首页(`discuss_post` 表)](#开发社区首页discuss_post-表)
      - [开发数据层](#开发数据层)
    - [开发业务层](#开发业务层)
    - [开发视图层](#开发视图层)
    - [开发分页组件](#开发分页组件)
  - [开发注册登录模块](#开发注册登录模块)
    - [发送邮件](#发送邮件)
    - [注册功能](#注册功能)
    - [生成验证码](#生成验证码)
    - [登录退出功能(`login_ticket` 表)](#登录退出功能login_ticket-表)
    - [显示登录信息](#显示登录信息)
    - [上传头像](#上传头像)
    - [检查登录状态](#检查登录状态)
  - [开发核心功能](#开发核心功能)
    - [敏感词过滤](#敏感词过滤)
    - [发布帖子](#发布帖子)
    - [显示帖子内容](#显示帖子内容)
    - [显示评论(`comment` 表)](#显示评论comment-表)
    - [添加评论](#添加评论)
    - [显示私信列表(`message`表)](#显示私信列表message表)
    - [发送私信](#发送私信)
    - [统一异常处理](#统一异常处理)
    - [统一日志处理](#统一日志处理)
  - [Redis](#redis)
    - [点赞](#点赞)
    - [收到的赞](#收到的赞)
    - [关注](#关注)
    - [个人主页](#个人主页)
    - [关注列表和粉丝列表](#关注列表和粉丝列表)
    - [优化登录模块](#优化登录模块)
      - [存储验证码](#存储验证码)
      - [存储登录凭证](#存储登录凭证)
      - [缓存用户信息](#缓存用户信息)
    - [热帖排行](#热帖排行)
  - [Kafka](#kafka)
    - [发送系统通知](#发送系统通知)
      - [触发事件](#触发事件)
      - [消费事件](#消费事件)
    - [显示系统通知](#显示系统通知)
      - [通知列表](#通知列表)
      - [显示通知详情](#显示通知详情)
      - [显示未读通知总数](#显示未读通知总数)
  - [Elasticsearch](#elasticsearch)
    - [开发社区搜索功能](#开发社区搜索功能)
  - [`Spring Quartz`实现定时热帖排行](#spring-quartz实现定时热帖排行)
  - [优化网站的性能](#优化网站的性能)
  - [项目发布](#项目发布)
  - [相关问题](#相关问题)
    - [MySQL](#mysql)
    - [Redis](#redis-1)
    - [Spring](#spring)
    - [分布式Session](#分布式session)

<!-- /TOC -->

# iCommunity

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407204344.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407210435.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210408051504.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210408051716.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210408051708.png)

## 功能简介

一个仿照牛客网实现的讨论社区，不仅实现了基本的注册，登录，发帖，评论，点赞，回复功能，同时使用前缀树实现敏感词过滤，使用wkhtmltopdf生成长图和pdf，实现网站UV和DAU统计，并将用户头像等信息存于七牛云服务器。

自学项目。开发仿牛客网社区，实现注册、登录、修改信息、发帖、评论、点赞、关注等功能。

## 主要技术：

- 利用 `ThreadLocal` 保存用户状态，通过拦截器拦截请求，根据自定义注解判断用户登录状态。
- 使用 Ajax 异步发帖、发送私信、评论，通过字典树过滤敏感词。
- 使用 Redis 实现点赞、关注功能，优化登录模块——存储登录凭证、缓存用户信息、存储 kaptcha 生成的验证码。

- 完成了用户登录注册模块, 使用拦截器实现了统一的登录状态验证，期间学习到了Cookie、Session、JWT等身份认证相关的技术
-

- 使用`Spring Security` 做权限控制，替代拦截器的拦截控制，并使用自己的认证方案替代`Security` 认证流程，使权限认证和控制更加方便灵活。
- 使用`Redis`的`set`实现点赞，`zset`实现关注，并使用`Redis`存储登录`ticket`和验证码，解决分布式`session`问题。
- 使用`Redis`高级数据类型`HyperLogLog`统计`UV(Unique Visitor)`,使用`Bitmap`统计`DAU(Daily Active User)`。
- 使用`Kafka`处理发送评论、点赞和关注等系统通知，并使用事件进行封装，构建了强大的异步消息系统。
- 使用`Elasticsearch`做全局搜索，并通过事件封装，增加关键词高亮显示等功能。
- 对热帖排行模块，使用分布式缓存`Redis`和本地缓存`Caffeine`作为多级缓存，避免了缓存雪崩，将QPS提升了20倍(10-200)，大大提升了网站访问速度。并使用`Quartz`定时更新热帖排行。

本项目是个人独立开发的后端项目，这要涉及到Spring、SpringMVC、Mybatis的整合，以及SpringBoot去简化Spring的配置开发。 主要的技术点：

- 登录注册功能：使用kaptcha去生成验证码，使用邮件完成注册，Redis优化验证码的保存，解决分布式session问题
- 使用拦截器拦截用户请求，将用户信息绑定在ThreadLocal上
- 构建Trie数据结构，实现对发表帖子评论的敏感词过滤
- 支持对帖子评论，也支持对评论进行回复
- 利用AOP对service的业务代码实现日志记录
- 利用Redis的zset并结合Redis实现点赞关注的功能
- 点赞关注后的系统通知，实时性不需要特别高，使用kafka实现异步的发送系统通知
- 使用ElasticSearch实现对帖子的搜索功能，以及结果的高亮显示
- SpringQuartz实现定时任务，完成热门帖子的分数计算模块
- 使用本地缓存Quartz缓存热门帖子优化热门帖子页面，提高了QPS（10 - 200）


- Spring Boot
- Spring
- Spring MVC、Spring Mybatis、Spring Security
- 权限@会话管理
  - 注册、登录、退出、状态、设置、授权
  - Spring Email、Interceptor
- 核心@敏感词、@事务
  - 首页、帖子、评论、私信、异常、日志
  - Advice、AOP、Transaction
- 性能@数据结构
  - 点赞、关注、统计、缓存
  - Redis
- 通知@模式
  - 系统通知
  - Kafka
- 搜索@索引
  - 全文搜索
  - Elasticsearch
- 其他@线程池、@缓存
  - 排行、上传、服务器缓存
  - Quartz、Caffeine

## 数据库表

### 用户表(`user`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| username | varchar | 用户名，创建索引 |
| password | varchar | 用户密码 |
| salt | varchar | 加密盐值 |
| email | varchar | 用户邮箱，创建索引 |
| type | int | 用户类型：0 普通、1 管理员、2 版主 |
| status | int | 用户状态：0 未激活、1 已激活 |
| activation_code | varchar | 激活码 |
| header_url | varchar | 用户头像地址 |
| create_time |    timestamp | 注册时间 |

### 评论表(`comment`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| user_id | int | 评论的用户 id，创建索引 |
| entity_id | int | 评论实体 id，创建索引 |
| entity_type | int | 评论实体类型：1 帖子评论、2 评论回复 |
| target_id | int | 评论目标 id |
| content | text | 评论内容 |
| status | int | 评论状态：0 有效、1 无效 |
| create_time | timestamp | 评论发表时间 |

### 帖子表(`discuss_post`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| user_id | int | 评论的用户 id，创建索引 |
| title | varchar | 帖子表标题 |
| content | text | 帖子内容 |
| type | int | 帖子类型：0 普通、1 置顶 |
| content | text | 评论内容 |
| comment_count     | int | 评论数量 |
| status | int | 帖子状态：0 普通、1 精华、2 拉黑 |
| create_time | timestamp | 评论发表时间 |

### 用户登录凭证表(`login_ticket`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| user_id | int | 登录用户 id |
| ticket | varchar | 登录凭证，随机字符串 |
| status | int | 登录状态：0 有效、1 无效 |
| expired | timestamp | 过期时间 |

### 消息表(`message`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| from_id | int | 发消息的 id，创建索引 |
| to_id | int | 收消息的 id，创建索引 |
| conversation_id | varchar | 会话 id，由通信双方 id 拼接，创建索引 |
| content | text | 消息内容 |
| status | int | 消息状态：0 未读、1 已读、2 删除 |
| create_time | timestamp | 消息发送时间 |

## 开发社区首页

封装帖子实体类，还有用户实体类，还有`Page`页面类，我们根据帖子查询。
### 搭建基本环境

构建 SpringBoot 的 maven 项目，引入 mysql 和 mybatis 依赖。

在 `application.properties` 配置文件中：

- 关闭 thymeleaf 缓存
- 配置数据库，设置基本连接信息、最大线程数，最小空闲线程数，最大空闲时间等
- mybatis，设置 mapper 文件的位置、实体类包名、使用主键等
- 创建 community 数据库和数据库表。

用户相关操作：

- 创建对应 user 表的 `User` 实体类
- 创建 `UserMapper` 接口，使用 `@Mapper` 注解
- 创建 `UserMapper.xml`，重复 sql 语句可以写在 `<sql id = "xxx">` 标签，通过 `<include refid="xxx"/>` 引用。

### 开发社区首页(`discuss_post` 表)

功能拆分：开发社区首页，显示前 10 个帖子。开发分页组件，分页显示所有帖子。

用到的表是 `discuss_post` 数据库表，包括帖子 `id`、发帖人 `id`、标题、内容、类型、状态、发帖时间、评论数量（为了提高效率，避免关联查询，因此冗余存储）、分数（用于进行热度排名）。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201321.png)

#### 开发数据层

帖子相关操作：

- 创建对应 `discuss_post` 表的 `DisscussPost` 实体类。

- 创建 `DisscussPostMapper 接口`，使用 `@Mapper` 注解。

  - 分页查询中用户 `id` 是可选参数，通过动态 SQL 选择，如果为 0 就不使用，在开发用户个人主页查询用户发帖记录时需要使用。
  - 如果只有一个参数，并且在动态 SQL 的 `<if>` 里使用，必须使用 `@Param` 加别名。
- 创建 `DisscusspostMapper.xml`。
  - `where status != 2` :拉黑的帖子不展现。
  - `<if test="userId!=0">`: `userID` 为 0 时不使用，按照类型，发帖时间排序。

### 开发业务层

- 创建 `DiscussPostService` 类，可以分页查询帖子和帖子数量。
- 创建 `UserService` 类，实现根据 `id` 查询用户功能，因为显示帖子时不显示用户 `id`，而是显示用户名。

### 开发视图层

- 把静态资源 css、html、img、js 放到 `static` 目录下。
- 把模板 mail、site、`index.html` 放到 `template` 目录下。
- 创建 `HomeController`，`getIndexPage` 方法，用 map 集合把帖子和用户封装到一起。
- 修改 `index.html`，使用 `<th:text="${map.xxx.xxx}"` 动态替换。

### 开发分页组件

- 创建 `Page` 实体类，封装分页信息，包括当前页码、显示限制、帖子总数、查询路径等。显示的起始页不能小于 1，最大页不能超过 `total`。
- 在 index.html 中，当 `page.rows > 0` 时显示分页信息。
- 如果 `page.current` 等于 1 或 `page.total`，代表是首页或末页，此时不能点击上一页和下一页，用 `disabled` 属性实现。

## 开发注册登录模块

验证码：浏览器先`get`请求验证码，服务端在`cookie`中添加信息验证这是同一人输入的验证码（在`redis`与浏览器中设置过期信息）

登录：登录后在`cookie`中添加`ticket`，浏览器每次都带着`ticket`来请求，服务端获取去和`redis`中的比对，成功就使用`threadlocal`去持有这个用户的信息。返回页面结束后就移除这个用户的信息。

问题：如果要保证同一时间只能有一个用户登录呢？

我的想法是维护一个`map`, 键为用户`id`，值为`ticket`的。每次浏览器带着`ticket`来请求，从`ticket`中取出用户`id`和`map`中的比对,如果不同则说明了有人后面登录这个账号，然后把`redis`
中的这个`ticket`删除，重定向到登录页面。

### 发送邮件

- 在网易邮箱打开 SMTP 服务。
- 引入 spring-boot-starter-mail 依赖。
- 在配置文件配置主机、端口、发送邮箱、授权码等。
- 创建 `MailClient` 类，调用 `JavaMailSender` 发送邮件。
- 使用 thymeleaf 发送 HTML 邮件，调用 `TemplateEngine` 把信息封装到 HTML 模板。

### 注册功能

- 把 `register.html` 地址关联到首页的注册 `href` 属性。
- 设置域名、创建 `CommunityUtil` 工具类，在工具类创建生产随机字符串和 MD5 加密方法。
- 创建 `LoginController`，创建 `getRegisterPage` 方法，跳转注册页面。
- 在 `UserService` 中创建 `register` 方法，判断注册信息合规后插入数据库，发送激活邮件。
- 在 `LoginController` 创建 `register` 方法，调用 `UserService` 的 `register` 方法。
- 创建接口 `CommunityConstant`，定义激活码的三种状态，成功、重复、失败，让 `UserService` 和 `LoginController` 实现该接口。
- 点击激活邮件的 `url` 【本地服务器的url】后，服务器通过 `LoginController` 的 `activation` 方法查询数据库用户，如果 `url` 中的激活码和设置的一样，就把用户 `status` 改为 1。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201343.png)

需要先开发验证码功能还有完成邮件工具类功能、

前期我们通过`session`存储验证码(后期通过`redis`改进系统性能)

验证了`session`跟前台的值是否匹配后，先查询数据库中是否已经存在当前用户名或者已经存在相同的邮箱等，如果符合条件，随机生成一个激活码注入到`user`中，然后则通过`Context`和`templateEngine`
访问邮件页，并将其转换为`String`格式发送给邮箱。(此处需要使用到激活需求)

当我们使用邮件传来的网址访问时，我们请求会访问数据库，将我们当前的账户激活。(激活页面会带有`userId`和`activationId`，会和发送邮件前在数据库中存储的信息进行比对，如果成功就设置`status`)

流程：

1. 写注册方法,返回值用map返回对应的消息。
2. 首先对传进来的user对象做一个空值的判断
3. 然后再验证账号和邮箱是否已注册过了
4. 再补全user对象的值，生成盐然后对密码进行加密
5. 注册用户都是普通用户，type设为0，状态设置为未激活0，再生成一个激活码随机字符串
5. 头像使用牛客网的默认头像，0-1000号头像都可以使用
6. 注册时间生成后插入对象就可以了
7. 最后用模板引擎生成html邮件，进行发送。

在service中发送邮件,使用thymeleaf提供的context，设置email属性，并将发送方的邮件赋给该属性，接下来我们需要定义一个激活邮件的连接，用户点击该连接对其邮箱进行激活。格式如http://localhost:8080/community/activation/101/code，其中101表示用户id（创建之后自动生成），code表示激活码，然后将该链接赋值到context的url属性中，然后使用context对模板中的内容进行替换，替换之后的html赋值给content，然后使用mailClient工具类进行发送

在service层中，我们需要对用户传入的数据进行检查，对各种错误信息封装到map中，主要对空值和重复值进行验证。注册用户其实就是实例化一个user，然后调用mapper的insert方法加入数据库，其中salt和激活码都是使用CommunityUtil.generateUUID()
生成的，在CommunityUtil中封装了md5方法和生成UUID的方法，头像链接使用的是牛客提供的网址"http://images.nowcoder.com/head/%dt.png，其中%d需要替换成0-1000之间的整数

在controller层中，我们需要使用POST方法进行注册，如果map为空这说明service层没有发送错误，那就提示用户去激活，和设置跳转页；如果有错误那就将Msg封装进model中，在模板中渲染

// http://localhost:8080/community/activation/101/code
在sercive层中通过传入的user_id得到用户，如果用户状态码已经是1了那么返回激活重复提示信息（在CommunityConstant中声明），如果该链接的code和用户的激活code相同，那么我们只要将用户的状态设置为1即可，返回激活成功激活码，其他情况都返回激活失败

在controller层中，我们使用@PathVariable注解得到url中的userId和code，然后调用service即可，根据返回的状态码设置操作结果模板并返回。

### 生成验证码

- 在 `pom.xml` 导入 kaptcha 的 jar 包。
- 创建配置类 `KaptchaConfig`，设置验证码的大小、范围、长度等。
- 在 `LoginController` 类新增 `getKaptcha` 方法生成验证码图片。
- 在 login.html 中，将刷新验证码的链接绑定 `refresh_kaptcha` 方法，通过 `id` 选择器获取 img 组件，重新访问 `getKaptcha` 方法生成验证码图片。
- 【问题】由于访问同一个生成验证码路径，需要在 `url` 参数加上一个随机数字，保证会重新请求获取新图片。

先保存在`session`，后续优化保存至`redis`

使用`Redis`存储验证码:使用`set`

- 验证码需要频繁的访问与刷新，对性能要求比较高
- 验证码不需要永久保存，通常在很短的时间后就会失效（`redis`设置失效时间）
- 分布式部署的时候，存在`Session`共享的问题（之前验证码是存到`session`里面，使用`redis`避免`session`共享问题）

`key:kaptcha:owner`

`value:string`

`owner` : 由于此时用户还未登录，`owner`为临时生成的凭证,存到`cookie`中发送给客户端。登录的时候从`cookie`中取值构造`redisKey`,再从`redis`中取值。并与用户输入的验证码进行比对。

1. 最初是直接将验证码字符串存到`session`当中，每次都是从`session`中获取验证码字符串的值在进行判断，这同样会出现分布式`session`
   的问题，比如说刷新验证码是一次请求，此次请求将验证码存到了服务器A的`session`当中，但是在点击登录按钮，去触发登录请求是，则将此次请求转到了服务器B,而服务器B并没有存储验证码的`session`，就会出现无法判断的问题。
2. 生成验证码的时候用户还未登录，此时随机生成一个`kpatchowner`字段标明当前用户，并存到`cookie`中，同时将`kaptchowner`字符串作为`redis`的`key`，具体的验证码的值作为`redis`
   的`value`。
3. 用户进行登录验证的时候，先从`cookie`中取出`kpatchowner`字段，得到唯一标明属于此用户验证码的`rediskey`，再从`redis`中取出验证码真正的文本，然后与用户的输入进行比对，判断你验证码是否正确。

最后再看controller中，注入之前声明了的kaptchaProducer，然后使用Produce提供的方法生成验证码和图片，然后将验证码写入session中（每个用户都有自己的session，服务器会将sessionId写入cookie中返回给用户，下次用户访问时带着cookie，服务器根据cookie中的sessionId得到session的内容）。然后将图片输出给浏览器，具体是得到response的输出流，然后使用ImageIO.write将image以png格式放到os中输出

### 登录退出功能(`login_ticket` 表)

本项目中先采用将用户登录信息存到数据库的`login_ticket`表中，后续采用存到`redis`。登陆成功的时候生成登录凭证，生成`Loginticket`往数据库`login_ticket`存，并且被设置为`cookie`
，下次用户登录的时候会带上这个`ticket`，`ticket`是个随机的UUID字符串，有过期的时间`expired`和有效的状态`status`。

用`login_ticket`存储用户的登录信息，每次请求会随着`cookie`带到服务端，服务端只要与数据库比对携带的`ticket`，就可以通过表中的`used_id`字段查到用户的信息。 用户退出时将`status`更改为0即可。

登录成功时，需要生成一个登录凭证发送给客户端。凭证可以在多个业务中连续地验证用户的登陆状态，凭证信息存储在 `login_ticket` 数据库表中，`status` 的 0 和 1 表示有效和无序，`expire` 表示过期时间。

- 创建对应 `login_ticket` 表的 `LoginTicket` 实体类，对应 `login_ticket` 数据库表。
- 创建 `LoginTicketMapper` 接口，通过 `@Insert`、`@Select`、`@Update` 注解来插入、查询、更新凭证。

- 在 `UserServce`

  - 创建 `login` 方法，验证账户合规后将凭证信息插入数据库，添加登录凭证到 map 中。
  - 创建 `logout` 方法，将对应凭证设为无效。

- 在 `LoginController`

  - 创建 `login` 方法，判断验证码正确后调用 `UserServce` 的 `login` 方法，如果 map 包含 `ticket` 代表登录成功，重定向跳转首页，否则添加错误信息并跳回登录页。
  - 创建 `logout` 方法，判断验证码正确后调用 `UserServce` 的`logout` 方法，跳转至登录页。

- 在 `login.html` 绑定登录链接，`index.html` 绑定退出登录链接。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201401.png)

验证前台的验证码与`session`中的验证码是否相符，如若不符，返回错误消息。

验证用户的账号与密码，如若没有此账号则返回没有此账号，如若是密码出错，我们则显示，密码错误返回给前台。如若都正确，我们就跳转至首页，并且存储一个登录凭证給数据库。我们如果点击退出登录，我们在数据库中的登录凭证就更改状态为1

使用`Redis`存储登录凭证，作废`login_ticket`:使用`set`数据结构

处理每次请求的时候，都要从请求的`cookie`中取出登录凭证并与从数据库`mysql`中查询用户的登录凭证作比对，访问的频率非常高（原来登录凭证`ticket`是存到`mysql`里面，`ticket`如果用`redis`
存，`mysql`就可以不用存了，`login_ticket`可以作废）

key:ticket:ticket

value:Loginticket(Json字符串)

第二个`ticket`为实际的`ticket`字符串，`Loginticket`被序列化为`Json`字符串。

退出登录的是，需要让登录凭证失效，此时根据`key`将`Loginticket`取出来，在更改其状态为1失效态，再重新存回`Redis`中。 （不删除可以保留用户登录的记录）

在Controller层用户需要给出账号密码、验证码、是否记住，同时需要用到session和response。
首先我们需要从session中获取验证码然后和用户输入的进行对比，如果出现错误就写入codeMsg并返回，然后我们需要根据rememberme得到登录凭证的过期时间，具体内容还是在CommunityConstant中设置了，没勾选的话是12小时，勾选的话是100天。然后调用service层进行账号密码验证，如果登录成功就将登录凭证存入浏览器的Cookie中，并设置内容、路径、过期时间，登录成功之后重定向到首页，如果登录失败就把提示信息装入model中，然后返回登录页

### 显示登录信息

包括以下步骤：

- 在请求之前先查到登录用户
- 在本次请求中持有用户数据
- 在模板视图上显示用户数据
- 在请求结束时清理用户数据

浏览器存着ticket放在cookie中，每次访问服务器，都会把这个ticket发送给服务器，从而得到当前用户是谁（login_ticket），得到user后，把它放在model中，最终html中则显示了用户信息。

把user信息放在ThreadLocal中，这样在整个请求过程中，user都一直存在，并能被访问。

当用户登录过后，之后的请求都应该以登录态去访问，也就是每次带上`ticket`
，例如网站首页，登录和未登录的显示应该不同，如果我们按照正常逻辑，每个请求都得判断登录态，处理相关逻辑。而使用拦截器，则可以拦截浏览器的请求，再对其进行统一的处理。

定义好拦截器过后，我们还需要一个配置类对它进行配置。在`config`包下新建`WebMvcConfig`类，并实现`WebMvcConfigurer`接口。

注入拦截器，重写添加拦截器方法。

- `.excludePathPatterns`把静态资源排除在外，不进行拦截
- `.addPathPatterns`添加拦截路径


- 创建 `CookieUtil` 工具类，通过 `name` 查询对应 cookie 的 `value`。
- 在 `UserService` 中新增 `findLoginTicket` 方法，根据 `ticket` 查询 `LoginTicket`。
- 创建 `HostHolder` 类用来模拟 `session` 的功能，利用 `ThreadLocal` 实现，存储用户信息。
- 创建 `LoginTicketInterceptor` 拦截器，实现 `HandlerInterceptor` 接口。
  - 在 `preHandle` 方法中通过 `CookieUtil` 的 `getValue` 方法查询是否有凭证 `cookie`，如果有则通过 `UserService` 的 `findloginTicket` 方法查询用户
    ID，再通过用户 ID 查询用户。最后将用户放入 `hostHolder` 中。
- 在 `postHandle` 方法中通过 `hostHolder` 的 `get` 方法获取用户，并将其存入视图中。
- 在 `afterCompletion` 方法中清除 `hostHolder` 中存放的用户信息。
- 创建 `WebMvcConfig` 配置类，实现 `WebMvcConfigurer`接口，配置 `LoginTicketInterceptor`，拦截除了静态资源之外的所有路径。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201418.png)

因为我们在前端页面并不知道我们是否已经登录，所以我们需要导入拦截器显示已经登录的消息，在拦截器中查看当前浏览器是否有`cookie`，如果没有则不用在本次页面请求中加入`user`
,如果有，则判断本次登录的凭证是否还存活，如果还存活，则将此`cookie`的`user`存储到`model`中，并在前端中展示

1. 接收浏览器传来的用户名、密码、验证码、是否记住我，这里还要用到`model`、`session`和`response`
2. 首先判断验证码是否正确，从`session`中取出登录页面生成的验证码，返回类型是对象，强制转换为`String`。不正确就返回验证码错误的消息，并返回登录页面
3. 首先根据是否记住我，选择登录凭证过期时间，然后调用`login`，使用`map`接收返回的信息
4. `map`里有`ticket`说明登录成功，将`ticket`存入`cookie`通过响应发送给浏览器，并重定向到首页
5. 登录失败就返回相应错误消息，跳转到登录页

用户登录后拿到`ticket`存到`cookie`，之后每次请求都带上`ticket`，拦截器拦截请求，用`ticket`查询`login_ticket`，再查询`user`，将`user`添加到`model`
中，模板引擎根据有无`user`及`user`的值去渲染页面。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407234132.png)

我们要从`cookie`中拿到`ticket`的值，先封装一个`cookieUtil`。

比较简单，直接写静态方法，不交给容器管理。传入`request`和我们想要的`cookie`的值。首先判断空值的情况，然后遍历`cookie`，找到我们想要的那个。

浏览器同时处理多个用户请求，对每个用户的`user`对象要做一个存储，可以使用`session`，但是`session`依赖`servlet api`
，我们想要在方法里随用随取，anywhere！为了解决这个问题，我们就要采取一种新的方法来存储用户信息——`ThreadLocal`。

`ThreadLocal`，顾名思义，就是本地线程，可是这个名字实在容易让人误解，因为其实它是本地线程局部变量的意思，首先我们要知道，我们每个请求都会对应一个线程，这个`ThreadLocal`
就是这个线程使用过程中的一个变量，该变量为其所属线程所有，各个线程互不影响。

我们封装一个工具`HostHolder`，用来持有用户信息，代替`session`对象。主要有添加查询和删除方法。

在`Interceptor`包下新建`LoginTicketInterceptor`。首先重写`preHandler`方法，利用前面封装的`cookieUtil`工具得到`ticket`，查到用户，并用`hostHolder`
持有用户。然后重写`postHandle`方法，在`modelAndView`上加上`user`。请求结束后，清理掉不需要的用户数据。

声明拦截器（实现`HandleInterceptor`）并在`spring @Configuration`中配置拦截信息

- 在请求开始时查询登录用户
- 在本次请求中持有用户数据

使用拦截器`Interceptor`来拦截所有的用户请求，判断请求中的`cookie`是否存在有效的`ticket`，如果有的话就将查询用户信息并将用户的信息写入`ThreadLocal`
在本次请求中持有用户，将每个线程的`threadLocal`都存到一个叫做`hostHolder`的实例中，根据这个实例就可以在本次请求中全局任意的位置获取用户信息。

`redis`是存储用户登录的状态，是在用户登录之后，跨不同的请求的，而使用`ThreadLocal`
具体针对的是一次请求，在这次请求中去存储用户信息，方便程序的开发，比如说我请求了帖子详情页面，去做评论或者回复，就可以直接从`threadLocal`中取到用户的信息，进行编码。

我们需要将通过ticket登录的用户的用户信息存入内存中。因此我们需要实现两个功能，一个是能够将cookie中的内容读到，然后使用ticket进行登录，第二个是如何将当前登录的用户信息存入内存中。
首先我们实现如何将用户信息存入内存中，本来我们可以将用户信息存入session中，但是这会增大服务器压力。这里我们使用ThreadLocal来实现，这个类以线程为key，value为对象，也就是不同的用户是不同的线程，也就是不同的key，调用get()
，会得到自己线程的user对象，set()会以当前线程的id为key存放user，clear()用于清除users

然后读取cookie中的内容，我们需要实现一个拦截器，这个拦截器可以在每次controller之前，调用controller之后以及模板引擎执行完之后执行相应的方法。 preHandle()
方法主要用于在调用controller之前执行，也就是在这里我们使用cookie中的凭证去验证用户是否需要登录。在查询凭证是否有效时，我们需要查看是否有该凭证，该凭证的status和过期时间。如果有效就使用userService查询相关用户并加入hostHolder中的users中。
postHandle()主要将hostHolder中的user加入到模板中，这样就能在模板中直接获取登录用户的信息了。 afterCompletion()用于在完成模板渲染之后清除users。
（该方法的在每次请求controller都会调用该拦截器一次，代价是不是有点高？）

声明好拦截器之后，我们还需要将该拦截器配置好。 在该配置类中需要实现WebMvcConfigurer接口，也就是addInterceptors()，也就是添加拦截器方法，需要注明添加的拦截器和不拦截的路径。

### 上传头像

- 在 `UserService` 新增 `updateHeader` 方法，更改指定用户的头像。

- 创建 `UserController`
  - 新增 `getSettingPage` 方法访问账户设置 setting.html ，并在 index.html 的账号设置按钮关联该链接。
  - 新增 `uploadHeader` 方法更新用户头像，如果上传出现错误将错误信息存在 Model 对象中。
  - 如果没有错误，生成一个文件对象 `dest`，利用 `MultipartFile` 接口的 `transferTo` 方法将用户上传文件导入 `dest`，并从 `hostHolder` 中取出用户，更新用户的头像路径。
- 新增 `getHeader` 方法获取用户头像，利用文件输入流读取图片数据，利用 `HttpServletResponse` 的字节输出流再进行输出。
- 调整 `setting.html` 的 `form` 表单， `method="post"，enctype="multipart/form-data"`，并设置提交路径。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201434.png)

这里用到的是`Spring MVC`的`multipartFile`，头像的存储和获取直接在`controller`层操作。新建一个`UserController`。

上传头像的方法，这里从容器获取两个对象，一个是`MultiparFile`，也就是从浏览器传过来的头像文件，一个是`model`，用于模型返回信息。

首先对空值进行处理，然后用`substring`分割出文件后缀，`png`或者`jpg`等等。如果没有后缀就提示文件格式不正确。对用户上传的图片重命名，用之前写的生成`uuid`的方法加上分割出来的文件后缀。

再在我们指定的文件存放位置新建一个文件，文件名使用生成的名字，并记录异常，将异常向上抛出，用于之后的处理。

然后从`hostHolder`里获取当前用户，更新头像路径。

头像获取，从访问路径中截取头像文件名，从容器获取`response`对象，用服务器存放的全路径覆盖文件名，使用文件输入流和`response`的输出流，建一个1024字节的缓冲区，从本地头像文件读取，输出到`response`里。

### 检查登录状态

- 利用拦截器，实现只处理带有自定义注解的方法，防止用户在未登录情况下通过 `url` 访问没有权限的页面。
- 创建 `@LoginRequired` 自定义注解，作用范围在方法上，有效期为运行时。
- 在 `UserController` 中需要在登录状态下调用的方法，访问设置页面、修改密码、上传头像等加上自定义注解。
- 创建 `LoginRequiredInterceptor` 拦截器，在 `preHandle` 方法中判断方法是否加了 `@LoginRequired` 注解，如果加了注解并且此时从 `hostHolder` 中获取不到用户则拒绝访问。
- 在 `WebMvcConfig` 配置类配置 `LoginRequiredInterceptor`，拦截除了静态资源之外的所有路径。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201446.png)

我们在前面开发的账号设置，并不能让每个用户都登陆，如果没登录的话就不能登录，那我们该如何实现这个功能呢，通过注解与拦截器，我们实现拦截未登录用户。怎么实现的呢，如果登录了的话，我们在本次请求中`hostHolder` 保留有`User`
，我们在拦截器中判断是否有`User`就可以判断是否已经登录。

新建一个`annotation`包，包下新建一个`annotation`类。定义好注解后，在需要登录才能访问的方法上面加上注解，目前主要就是设置界面和上传头像需要登录。

使用注解标记需要处理的方法后，定义拦截器进行统一处理。这里只对响应前进行处理，也就是只重写`preHandle`。

首先判断拦截对象是不是一个方法，如果是的话讲`Object`对象转型成`HandlerMethod`对象。获取拦截的方法，查找该方法有没有我们写的`@LoginRequired`注解。有的话看`hostHolder`里有没有`user`
，如果有注解没`user`就重定向到登录页面，这里不是在`controller`层，所以需要用`respons`重定向。

有些路径必须登录才能访问，因此我们需要对用户是否登录进行检查。 我们可以通过自定义一个注解，使用该注解的方法必须用户登录才能访问。 自定义注解我们只需要说明该注解的作用目标，注解起作用的时长，然后使用@interface声明即可。

然后我们还需要声明一个拦截器用于检查用户是否登录。该拦截器主要在controller之前调用，如果拦截到的可以转换为方法的话，那么表示可能是我们自定义注解的方法，此时就检查该方法的注解是否有我们自定义的LoginRequired，如果有并且用户没有登录的话就重定向到登录页面，并且返回false不再执行controller方法，没有的话就返回true，执行controller方法。

## 开发核心功能

### 敏感词过滤

利用字典树数据结构解决。

- 创建 `SensitiveFilter` 类
  - 创建静态内部类 `TrieNode` ，通过 `boolean` 类型的结束符判断是否匹配到关键字尾部。
  - 利用 `@PostConstruct` 注解，在构造方法执行后初始化字典树。
  - 添加 `filter` 方法，利用双指针进行匹配，过滤敏感词

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200756.png)

### 发布帖子

- 引入 fastjson 依赖，在 `CommunityUtil` 中新增 `getJSONString` 方法封装 JSON 信息。
- 在 `DisscussPostMapper` 接口新增 `insertDiscussPost` 方法，并在 `DisscusspostMapper.xml` 配置 `insert` 语句。
- 在 `DiscussPostService` 新增 `addDiscussPost` 方法调用 `DisscussPostMapper` 的 `insertDiscussPost` 方法，其中需要进行对标题内容和发帖内容进行 HTML
  转义以及过滤敏感词。
- 创建 `DiscussPostController` 类，新增 `addDiscussPost` 方法，调用 `DiscussPostService` 的 `addDiscussPost` 方法发帖。
- 在 `index.html` 中为发帖按钮绑定函数，利用 Ajax 向 `DiscussPostController` 的 `addDiscussPost` 方法发送 `POST` 请求。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200822.png)

前端判断用户是否已经登录，若无登录，发布帖子的功能按钮便不会展现在前端，因为我们不想一次刷新就把整个页面都刷新，所以我们导入了fastJson这个包，前端页面只用js代码(jquery代码)
异步请求就可以实现帖子的发送，把前端的内容和标题发送给`controller`,在`controller`调用`service`，存入数据库。

### 显示帖子内容

- 在 `DisscussPostMapper` 接口新增 `selectDiscussPostById` 方法，在 `DisscusspostMapper.xml` 配置 `select` 语句。
- 在 `DiscussPostService` 新增 `findDiscussPostById` 方法调用 `DisscussPostMapper` 的 `selectDiscussPostById` 方法。
- 在 `DiscussPostController` 新增 `getDiscussPost` 方法，调用 `DiscussPostService` 的 `findDiscussPostById`
  方法查询帖子内容，将 `DiscussPost` 对象和 `User` 对象（通过 `userId` 查询，不在 DAO 层关联查询）数据存放到 `Model` 对象，返回模板 `discuss-detail`。
- 在 `discuss-detail.html` 取出 `Model` 对象存放的数据绑定到对应组件显示。

其中，user_id代表发表评论的用户id，entity_type表示评论的对象是什么类型，是回复帖子还是回复其他人的评论，entity_id表示评论的对象的id，target_id表示回复的用户的id，content表示内容，status为0表示正常。

具体的操作我们主要在controller中进行操作，service层主要做的就是调用dao得到数据。查看帖子详情，我们需要从url中得到帖子id，然后调用service得到帖子，再得到帖子的作者，将帖子和作者加入到model中，然后评论多的话我们需要分页，因此需要设置分页信息。

然后我们得到回复帖子的所有评论，然后遍历每一个评论创建一个评论VO（Value Object）列表，方便模板显示。

commentVoList是一个列表，每一项是一个Map，map里需要存放评论、作者和相关的回复，而评论的回复其实也是一个泛型为Comment的列表，因此我们需要通过findCommentsByEntity的方法得到该评论的所有回复，设置entity_type为评论，entity_target为该评论的id，得到所有该评论的回复之后再将所有的reply加入到一个list中，每个reply为一个map，有回复内容，回复作者和回复目标（null或者User），最后将reply列表加入到该条评论的map中即可。

再模板中我们只需要遍历传入的CommentVOList和每一个评论的回复ReplyVOList即可。

### 显示评论(`comment` 表)

`user_id`对应的是发评论的用户，`entity_type`是指评论的类型，目前我们打算开发论坛部分，那么就有两种类型，对帖子的评论和对评论的评论，为了方便区分，对评论的评论我们成为回复，`entity_id`对应回复的实体的`id`
，`target_id`也就是回复的对象，这个主要是在回复的时候需要显示回复的谁

- 评论需要分页，所以传入`page`对象。
- 对`page`对象进行配置，一页显示5条，`page`的路径和总的评论数
- 首先用上面写的方法查询评论，放到`list`里，然后还需要进行一些处理。查询到的评论里只有`user_id`，没有用户名，同时评论下还有回复。
- `VO`代表显示对象，用来显示在页面上的对象。
- 整个逻辑就是查出当前帖子下的所有评论，遍历所有评论，处理用户名等信息，查询评论下的回复，遍历每个回复，处理用户名等信息。

- 创建 `comment` 表对应的实体类 `Comment`。
- 创建 `CommentMapper` 接口
  - 新增 `selectCommentsByEntity` 方法，根据实体查询一页的评论数据。
  - 新增 `selectCountByEntity` 方法，根据实体查询评论的数量。
- 在 `CommentMapper.xml` 配置 `select` 语句。
- 创建 `CommentService` 类
  - 新增 `findCommentByEntity` 方法，调用 `CommentMapper` 的 `selectCommentByEntity` 方法。
  - 新增 `findCommentCount` 方法，调用 `CommentMapper` 的 `selectCountByEntity` 方法。
- 在 `DiscussPostController` 的 `getDiscussPost` 方法中增加查询帖子评论和回复的逻辑，将结果存储在 `Model` 对象。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200856.png)

### 添加评论

使用了事务：

- 在 `CommentMapper` 接口新增 `insertComment` 方法，添加评论数据，在 `CommentMapper` 配置对应 sql。
- 在 `DiscussPostMapper` 接口新增 `updateCommentCount` 方法，增加评论数量，在 `DiscusspostMapper` 配置对应 sql。
- 在 `DiscussPostService` 类新增 `updateCommentCount` 方法，调用 `DiscussPostMapper` 的 `updateCommentCount` 方法。
- 在 `CommentService` 类新增 `addComment` 方法，调用 `CommentMapper` 的 `insertComment` 新增评论，并调用 `DiscussPostService`
  的 `updateCommentCount` 更新评论数量，使用 `@Transactional` 注解保证事务。
- 创建 `CommentController` 类，新增 `addComment` 方法，从 `hostHolder` 获取用户信息，然后调用 `CommentService` 的 `addComment` 方法添加评论。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201211.png)

添加评论的功能也是比较基础的，按照数据层业务层和表现层进行开发，比较特别的就是会用到前面提到的事务管理。

为了效率，在帖子的字段里设计了一个评论数量，那么我们添加评论的时候就要同时更新评论数量。

在添加评论的地方，我们插入了事务的概念，所谓事务就是一系列操作要么全部执行，要么全部不执行。在SpringBoot中我们使用@Transactional注解来注明该方法是事务，isolation表示隔离方式，propagation表示传播机制

在添加评论时我们需要对用户输入的内容进行格式化处理(标签等内容不会转义)
和过滤敏感词。添加完评论之后，如果是直接对帖子的回复，那么我们需要更新帖子的评论数量，根据entity_type和entity_id来得到评论总数，之所以要两个参数，是因为回复帖子的entity_id是帖子的id，而回复评论的entity_id是评论的id，两者可能会重复因此需要两个参数来定位。

### 显示私信列表(`message`表)

- 创建对应 `message` 表的实体类 `Message`。
- 创建 `MessageMapper` 接口，增加查询会话列表、会话数量、私信列表、私信数量、未读私信数量等方法，在 `MessageMapper.xml` 中配置对应的 sql。
- 创建 `MessageService`，调用 `MessageMapper` 中的方法。
- 创建 `MessgaeController`
  - 新增 `getLetterList` 方法，将会话列表信息存储到 `Model` 对象，返回 `letter` 视图。
- 新增 `getLetterDetail` 方法，将每个会话具体的私信信息存储到 `Model` 对象，返回 `letter-datail` 视图。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201223.png)

首先看一下数据库的设计，私信相当于一个对话功能，那么两个人就组成一个对话，这段对话里有A发给B的消息，有B发给A的消息，那么我们把发送者和接收者的id拼接到一起形成一个会话`id`，把`id`
小的拼接在前面。还有一种私信是系统通知，那么只需要把`from_id`指定一个固定的值，这里指定为1。

数据层新建`MessageMapper`，定义好方法。私信列表需要显示的内容：

- 显示当前用户的所有会话，那么每个会话只显示最新的一条消息就行了
- 还需要显示当前用户一共有多少会话
- 每个会话包含的所有私信
- 每个会话包含的所有私信数量
- 还有每个会话未读的私信数量

表现层要加载私信列表，从`hostholder`获取当前用户。将会话和私信内容，未读数量等封装到`List<map<>>`里。

然后继续开发会话详情功能。当前端点击会话列表中的某一个时，传入会话`id`，查询该会话`id`下的所有私信。页面上还需要显示发送私信的人，拆解`conversationid`，判断哪个是收信人。

得到私信列表同得到帖子列表类似，我们也需要将一个私信封装到一个map里，map中需要存放会话、会话的私信数、未读私信数和会话目标，然后将这些map放入一个列表中，然后放入model中返回。在这里，我们还要查询得到所有会话的未读消息数

查看会话详情也是类似，我们需要根据conversation_id查到该会话的所有私信，然后每个私信是一个map，map中存放了from_user和私信内容，所有私信放入一个列表中，然后加入model中，除此之外，model中还要放入该会话的目标user。其实这些需求都是根据前端的页面进行具体实现的，知道了需求才知道要设计什么接口。

最后用户既然已经查看了该会话，那么该会话的所有私信就不应该是未读信息了，要将它们全部置为已读，因此需要得到置为已读私信的id，这些私信满足to_id是当前用户且status为0，当然肯定是该会话的私信。

### 发送私信

我们定义的私信字段为id,from_id,to_id,conversation_id（为from_id和to_id的拼接，小的在前面）,content为内容，status为状态，以及create_time。

在dao层我们主要定义了查询当前用户的会话列表、会话数量、某个会话详情、某个会话消息数量以及新增数量、修改消息状态

在mapper层我们主要看两个方法的实现。

在这里要注意的就是to和from与用户之间的关系

第一个是查询全部的会话，并返回第一条最新消息。首先我们得到当前用户发送的或者接收的未删除的且不是系统通知的全部会话，然后以conversation_id进行分组，然后得到每个分组最大的id（最新私信），然后在外层得到这些id对应的message即可。

- 在 `MessageMapper`
  - 新增 `insertMessage` 方法插入私信记录，在 `MessageMapper.xml` 配置 `insert` 语句。
  - 新增 `updateMessage` 方法修改私信状态，在 `MessageMapper.xml` 配置 `update` 语句，利用 `foreach` 动态 sql。
- 在 `MessageService`
  - 新增 `addMessage` 发送私信方法，过滤敏感词后，调用 `MessageMapper` 的 `insertMessage` 。
  - 新增 `readMessage` 方法读取信息，调用`MessageMapper` 的 `updateMessage` 更新私信的状态为 1。

- 在 `MessageController`

  - 新增 `getLetterIds` 方法，将私信集合中未读私信的 `id` 添加到 `List` 集合并返回，在 `getLetterDetail` 方法调用该方法设置已读。
  - 新增 `sendLetter` 发送私信方法，设置私信信息后调用 `MessageService` 的 `addMessage` 发送。

私信某人说明两个人建立一个会话，每个人都有一个会话列表。数据库里面有个`message`表就是用来存储私信相关的信息。里面有几个重要的字段，一个是`from_id`这条私信发起者 ， 一个是`to_id`这条私信接收者。会话`id`
由这两个`id`拼接而成。查看私信就跟据会话`id`获取两个人的信息。未读消息由数据库`status`字段标记。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201234.png)

数据层首先在`MessageMapper`里新增两个方法，一个新增消息，一个修改消息状态的方法。

表现层接收前端传来的用户名和内容，创建`message`对象，补充相关内容，拼接`conversationId`的时候把小的拼在前面。

然后实现把未读消息改成已读。在之前写的加载消息列表的方法里补充一下。首先写一个方法获取所有未读消息的`id`。然后在`getLetterDetail`方法里加上设置已读的方法。

### 统一异常处理

- 在 `HomeController` 中增加 `getErrorPage` 方法，返回错误页面。
- 创建 `ExceptionAdvice` 类
  - 加上 `@ControllerAdvice` 注解，表示该类是 `Controller` 的全局配置类。
  - 创建 `handleException` 方法，加上 `@ExceptionHandler` 注解，该方法在 `Controller` 出现异常后调用，处理捕获异常。如果是异步请求返回一个 JSON
    数据，否则重定向至 `HomeController` 的 `getErrorPage` 方法。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201254.png)

- 首先使用`@ControllerAdvice`注解修饰类，指定范围是`controller`下的类
- 声明日志，然后写异常处理的方法，我们直接捕获所有异常
- 将异常写入日志，然后判断当前请求是需要返回页面还是数据，从请求中获取请求头参数`x-requested-with`，如果参数等于`XMLHttpRequest`，那么请求是一个异步请求，返回一个`json`
  字符，否则重定向到`error`页面。

们再创建一个异常处理类，统一处理controller发生的异常。

使用@ControllerAdvice注解，通过annotations参数声明只扫描带有Controller注解的Bean。然后用@ExceptionHandler({Exception.class})修饰handleException()
方法，该注解表示该方法在Controller出现异常（全部异常）之后调用。通过获取request中的“x-requested-with”参数得到请求方式，如果是XML，则是异步请求，此时通过response的输出流输出JSON对象即可，如果不是异步请求，就重定向到/error请求。

### 统一日志处理

- 在 `pom.xml` 引入 `aspectj` 的依赖。
- 创建 `ServiceLogAspect` 类，添加 `@Aspect` 切面注解，配置切入点表达式，拦截所有 `service` 包下的方法，利用 `@Before` 记录日志。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200647.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200706.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200718.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200730.png)

- `Target`：目标对象，也就是我们实现的业务，有很多地方可以织入代码
- `Aspect`：切面组件，`pointcut`声明织入到哪些目标的哪些织入点，`advice`具体的逻辑
- `JoinPoint`：织入点

实现比较简单，我们在用户访问每个服务的时候记录用户[1.1.1.1]，在[xxx]访问了[com.neu.langsam.community.service.xxx()].

使用`ServletRequestAttributes`获取`request`，从而获取`ip`，然后调用日志记录。

在SpringBoot中使用AOP很简单，我们需要声明一个组件，并用@Aspect注解修饰，首先我们需要定义切点，下面这个切点即service包下的所有java文件的所有方法，对参数也没有限制。

我们可以在切点之前（@Before(“pointcut()”)）

切点之后（@After(“pointcut()”)）

有返回值之后（@AfterReturning(“pointcut()”)）

抛异常之后（@AfterThrowing(“pointcut()”)）

切点之前之后（@Around(“pointcut()”)）

声明并实现相关的方法。

而目前我们只要记录日志，因此只需要在切点之前即可。首先使用@Component

@Aspect注解，然后创建一个Logger实例，声明好切点，然后在切点之前调用方法即可，该方法得到request，再用request得到ip，然后使用joinPoint得到类型名和方法名（也就说这些切点实际就是方法？），最后使用“用户xx,在xx时间,访问了xx方法”这样的格式记录日志

## Redis

在配置类中，我们主要通过RedisConnectionFactory数据库连接工厂将我们创建的RedisTemplate实例和redis连接，然后我们需要设置key和value的序列化方法，除此之外对于Hash类型的key和value我们要单独设置，在这里我们就设置为Redis提供的序列方法。

点赞支持对帖子、评论点赞，第一次点赞，第二次取消点赞。前端的需求有统计帖子的点赞数量、统计评论的点赞数量，以及显示当前用户的点赞状态。 这样的业务我们不再对controller和前端页面给出展示，最核心的应该是redis的设计和实现。

首先是点赞功能，我们需要存储的是某个实体被哪些用户点赞了，每一个实体可以拥有一个key，value应该是set类型，存放的是点赞用户的id。因此我们可以这样设计key：like:entity:entityType:entityId ->
set(userId)

而对于查询该用户是否给该实体点过赞只要在以该实体生成的key的redis中是否有该用户即可；查询某个实体的点赞数量只要查询该实体存储的用户数量有几个。
但是我们还有一个需求就是得到某个用户收到的赞，包括他发布的帖子和评论收到的赞，因此遍历原来的数据是不可能的，因此我们还需要一个数据库用来存储每个用户收到的赞，每次用户点赞的时候，我们不但让用户点赞的实体点赞增加，也让该实体的主人点赞也增加。

对于key我们可以这样设计like:user:userId -> int，值只要用value存储即可。

这样所有的需求都可以满足了，然后我们就可以开发service层了。

最主要的就是点赞了，由于需要修改两个数据库，因此我们需要引入事务。在redis中事务执行中不会乱入其他语句，事务使用的是乐观锁，这种方式运行exec前修改和查询。redis通过watch来检测数据，在执行exec前，检测的数据被其他人更改会抛出错误，取消执行，而在执行时保证不会插入其他语句来实现隔离。在执行事务时是所有语句一起执行的，因此查询语句要放在事务之外执行。

点赞方法需要传入点赞用户id，实体类型，实体id和实体主人id。使用execute（）方法执行事务，在SessionCallback参数中执行具体代码，并把执行结果作为参数。在SessionCallback参数的execute方法中我们通过RedisOperations类型参数对redis进行操作，multi()
方法用于开始事务。首先按照我们之前约定构造key，然后查询该用户是否已经对该实体点过赞了，如果点了，我们就将该用户从该实体的赞的数据库中移除，然后把实体目标用户收到的赞减一，如果没有点过赞，就增加即可。

查询某个实体被点赞数量只要查看以该实体组成的key的数据库中有多少数据即可，使用size（）方法即可。

查询某人是否对某个实体点过赞我们只要在该实体中查询是否有该用户的id即可，使用isMember()方法即可。

查询某个用户获得的赞，只要取得该用户的redis数据库的值即可。

关注的需求就是统计用户的关注数和粉丝数，关注的对象可以是用户、帖子、题目等，可以抽象为实体。

首先我们需要处理某个用户关注的实体，由于有多种实体，因此对于不同的关注实体我们存入不同的数据表中，因此我们可以以followee:userId:
entityType为key，以有序集合zset作为值，该zset以entityId为key，以当前时间为value(score)，表示该用户对该实体关注了哪些内容，分数是多少。

而某个实体拥有的粉丝我们需要通过实体类型和实体id指定实体，以此为key，而值我们还是用有序集合，存入粉丝id，即用户id，以及当前时间作为分数

然后我们在service层实现即可。

首先是关注和取消关注的实现，两者基本一致，这里只给出关注部分。我们需要传入用户id和实体类型实体id，和点赞一样，我们要在事务里执行，分别给该用户的关注中加入该实体，以及给该实体的粉丝中加入该用户。

查询某用户关注的实体数量，我们需要得到该用户id和需要查询的实体类型来构建key，然后查询该key的数据库中的数据量即可，zset使用zCard即可。

查询某实体的粉丝数量，我们需要传入该实体的类型和id

查询当前用户是否关注了该实体，我们只要在该用户的关注对象里查找是否有该实体即可。使用score得到该用户的分数，如果不存在就得不到。

然后我们还有两个需求就是得到某个用户关注的人，以及该用户的粉丝有哪些。

对于某个用户关注的人我们只要将实体类型设置为用户构建key，得到相应的zset，然后遍历即可。我们要根据时间排序，因此使用reverseRange()
方法，然后由于要分页，所以我们要通过offset和limit设置开始索引和结束索引。在遍历过程中，我们将得到的userId得到用户放入map中，将得到的now转换为Date类型之后也放入map中，然后将map放入list中，最后将list返回即可。

查询某用户的粉丝也是同理，只要将实体设置为用户，然后传入改用户的id构建key，然后遍历即可。过程和查询用户关注对象类似。

### 点赞

- 创建 `RedisKeyUtil` 工具类
  - 定义分隔符 : 以及实体获得赞的 `key` 前缀常量 `like:entity`。
  - 新增 `getEntityLikeKey(int entityType,int entityId)` 方法，通过实体类型和实体 `id` 生成对应实体获得赞的 `key`。
- 创建业务层的 `LikeService` 类
  - 注入 `RedisTemplate` 实例。
  - 新增 `like` 点赞方法，首先通过 `RedisKeyUtil` 工具类的 `getEntityLikeKey` 方法获得实体点赞的 `key`，然后通过 `RedisTemplate` 对象对 `set`
    集合的 `isMember` 方法查询 `userId` 是否存在于对应 `key` 的 `set` 集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。
  - 新增 `findEntityLikeCount` 方法查询实体的点赞数量，通过调用 `set` 集合的 `size` 方法查询元素个数。
- 新增 `findEntityLikeStatus` 方法查询某用户对某实体的点赞状态，逻辑如 `like` 方法，通过 `set` 集合的 `isMember` 方法实现。

- 创建表现层的 `LikeController` 类
  - 注入 `LikeService` 和 `HostHolder` 实例。
  - 新增 `like` 点赞方法，调用业务层的 `like` 方法进行点赞、调用 `findEntityLikeCount` 和 `findEntityLikeStatus` 查询点赞数量和点赞状态，封装到 map
    集合，然后通过工具类封装成 JSON 数据返回。

- （更新首页帖子点赞数量）在表现层的 `HomeController` 类
  - 注入 `LikeService` 实例。
  - 在 `getIndexPage` 方法在通过 `LikeService` 类的方法获得点赞数量，存储到 map 集合。

根据实体`id`和实体类型者两个参数确定点赞的目标，使用`redis`的`set`数据类型，`redis`根据实体`id`与实体类型为`key`，存储`value`是点赞用户`id`
，值得注意的是，当对一个实体点赞时候。该实体的拥有者也会获得一个赞。拥有者`id`为`key`，`value`加1（这里用了`redis`事务）。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201527.png)

- 支持对帖子、评论点赞
- 第一次点赞，第2次取消点赞(判断`userId`在不在`set`集合中，就可以判断用户有否点过赞，如果已经点过赞了，就将用户从集合中删除)
- 在查询某人对某实体的点在状态时，用可以用`boolean`作为返回值，但项目中使用`int`（支持业务扩展，可以支持是否点踩）

key:like:entity:entityType:entityId

value:set(userId)

`value`使用`set`集合存放`userId`是为了能看对谁点了赞

点赞时同样需要记录点赞实体的用户`id`,某个用户收到的赞

key:like:user:userId

value: int

某个用户关注的实体:

key:followee:userId:entityType

value:zset(entityId,now)

使用`zset`以当前时间作为分数排序

某个实体拥有的粉丝:

Key:follower:entityType:entityId

value: zset(userId,now)

### 收到的赞

对点赞功能进行重构

- 在 `RedisUnitl` 工具类
  - 新增用户获得赞 `key` 的前缀常量 `like:user`
  - 新增 `getUserLikeKey(int userId)` 方法，通过用户 `id` 生成对应用户获得赞的 `key`。

- 在 `LikeService` 中
  - 重构 `like` 方法，在参数列表中加入 `entityUserId` 表示被点赞用户的 `id`，用来更新用户的被点赞数量。
    - 通过 `RedisTemplate` 对象的 `execute` 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 `isMember` 方法查询用户的点赞状态，之后通过 `mutli` 方法开启事务。
    - 当用户已点赞时，调用 `remove` 方法将当前用户从点赞用户的集合中移除，调用 `decrement` 方法将被点赞用户的被点赞数减 1；当用户未点赞时，调用 `add`
      方法将当前用户添加到点赞用户的集合，调用 `increment` 方法将被点赞用户的被点赞数加 1。

  - 增加 `findUserLikeCount` 方法，以用户 `id` 作为 `key`，调用 `get` 方法查询用户所获得的点赞数。
- 在 `LikeController` 中给 `like` 方法增加 `entityUserId` 参数即可。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210424110920.png)

### 关注

- 在 `RedisUnitl` 工具类
  - 新增用户关注实体（帖子、评论、用户等）和粉丝（用户）的前缀常量 `followee` 和 `follower`
  - 新增 `getFolloweeKey(int userId, int entityType)` 方法，通过用户 `id` 和实体类型生成用户关注实体的`key`。
  - 新增 `getFollowerKey(int entityType, int entityId)` 方法，通过实体类型和实体 `id` 生成实体用户粉丝的 `key`。

- 创建业务层的 `FollowService` 类
  - 新增 `follow` 方法，当用户关注某实体时，
    - 调用 `add` 方法将当前实体 `id` 和时间作为 `value` 和 `score`加入用户的关注集合。
    - 调用 `add` 方法将当前用户 `id` 和时间作为 `value` 和 `score` 加入实体的粉丝集合。
  - 新增 `unfollow` 方法，当用户取消关注某实体时，
    - 调用 `remove` 方法将当前实体从用户的关注集合移除。
    - 调用 `remove` 方法将用户从实体的粉丝集合移除。

关注也类似，某个人关注一个人，这个人多一个关注另一个人多一个粉丝，因为用的是有序集合，第二个值`score`存储当前时间，关注列表那里根据时间进行顺序排序。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201554.png)

### 个人主页

- 在业务层的 `FollowService` 类
  - 新增 `findFolloweeCount` 方法，调用 `zset` 的 `zcard` 方法查询某用户关注的实体数量。
  - 新增 `findFollowerCount` 方法，调用 `zset` 的 `zcard` 方法查询某实体的粉丝数量。
  - 新增 `hasFollowed` 方法，根据 `zset` 的 `zscore` 方法返回值查询当前用户是否关注某实体。
- 在 `UserController` 中新增 `getProfilePage` 方法获取个人主页。
  - 调用 `LikeService` 的 `findUserLikeCount` 查询用户获赞数，并添加到 `Model` 中。
  - 调用 `FollowService` 的`findFolloweeCount`、`findFollowerCount` 、`hasFollowed` 方法分别查询关注数量、粉丝数量、用户是否关注三项信息并添加到 `Model`
    对象中存储。

### 关注列表和粉丝列表

- 在业务层的 `FollowService` 类

  - 新增 `findFollowees` 方法，查询用户关注列表，主要通过 `zset` 的 `reverseRange` 获取 `value` 即关注用户的 `userId`，再查询出其 `user`，之后通过 `score`
    获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。
  - 新增 `findFollowers` 方法，查询用户粉丝列表，主要通过 `zset` 的 `reverseRange` 获取 `value` 即粉丝的 `userId`，再查询出其 `user`，之后通过 `score`
    获取关注时间，存入 map 集合，将 map 添加到 `list` 列表返回。
- 在表现层的 `FollowController` 类
  - 新增 `getFollowees` 方法，获取关注列表，存入 `Model` 对象。
  - 新增 `getFollowers` 方法，获取粉丝列表，存入 `Model` 对象。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201604.png)

### 优化登录模块

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201619.png)

验证码需要频繁的访问与刷新，对性能要求较高。验证码不需要永久保存，通常在很短时间后就会失效，同时在分布式部署时，存在Session共享的问题。因此原先我们将验证码存在session中的方法需要进行重构。
我们可以将验证码存入到redis中，但是这里有一个问题，就是要将验证码和用户对应起来，但是此时用户没有登录，没有id，因此我们可以用一个随机码临时地标记一下这个用户。因此我们可以这样设计key，kaptcha:owner

然后在生成验证码的时候，我们随机生成一个标识符，我们需要将这个标识符存入cookie中，设置好过期时间传给浏览器，然后将验证码存入redis中，同时也需要设计redis的过期时间60s

在验证验证码的时候我们需要从cookie中得到这个临时标识符，要注意判断该cookie是否已经过期了，如果没有过期就以该标识得到key，然后得到验证码即可。

在每次controller请求前，我们都会拦截请求，查询cookie中的登录凭证，并进行验证。这其中涉及到两次数据库操作，一次是根据ticket得到LoginTicket，一次是根据LoginTicket查询用户然后加入到hostHolder中，因此这样效率可以说是极低。因此我们需要将频繁的数据库操作改成redis操作。
首先我们要设计redis的key，可以这样设计ticket:具体的ticket，然后在存储对象时，我们只要用opsForValue()即可，redis会将对象序列化为json格式的值存储。

最后我们需要对根据id查询用户方法进行优化，也就是findUserById()方法。我们可以这样实现，首先我们从缓存中取值，如果取不到，那么我们就去数据库中取，然后存入redis中，当数据变更时我们需要清楚缓存数据。

我们可以这样设计存储用户的key：user:具体的user

#### 存储验证码

- 在 `RedisUntil` 工具类
  - 新增验证码前缀常量 `kaptcha`
  - 新增 `getKaptchaKey` 方法，通过一个用户凭证（由于未登录，利用 `cookie` 实现）获得对应验证码的 `key` 值（利用 `string` 存储验证码）。
- 在表现层的 `LoginController` 类
  - 重构 `getKaptcha` 方法，将验证码存入 `redis`，`key` 值是当前随机生成的一个字符串，同时将该字符串存入 `cookie`。
  - 重构 `login` 方法，从 `cookie` 中获得随机字符串，生成验证码的 `key` 值，然后获取对应的 `value` 值即验证码。

#### 存储登录凭证

- 在 `RedisUntil` 工具类
  - 新增登录凭证前缀常量 `ticket`
  - 新增 `getTicketKey` 方法，通过字符串获得登录凭证的对应 `key` 值（利用 `string` 存储）。
- 在业务层的 `UserService` 类
  - 重构 `login` 方法，将登录凭证存入 `redis` 中。
  - 重构 `logout` 方法，先从 `redis` 中获取登录凭证对象，将状态设为无效再重新存储进 `redis`。
  - 重构 `findLoginTicket` 方法，根据 `ticket` 字符串获得对应登录凭证的 `key`，然后从 `redis` 查询登录凭证。

#### 缓存用户信息

- 在 `RedisUntil` 工具类
  - 新增用户前缀常量 `user`
  - 新增 `getUserKey` 方法，通过用户 `id` 获得用户的对应 `key` 值（利用 `string` 存储）。
- 在业务层的 `UserService` 类
  - 新增 `getCache`，从缓存获取用户信息。
  - 新增 `initCache`，从 MySQL 查询用户信息并存入 `redis`。
  - 新增 `clearCache`，用户信息变更（更新头像，激活）时清除缓存。
  - 重构 `findUserById` 方法，首先调用 `getCache`从缓存获取用户信息，如果获取为 `null` 则调用 `initCache`。

### 热帖排行

## Kafka

我们使用消息队列只要是为了处理用户被评论、点赞和关注之后生成一个消息存入数据库中然后发送给用户。根据需求，我们需要告诉用户消息的种类是什么(评论、点赞还是关注)
，这条消息是什么，这条消息是由哪个用户产生的。因此，我们可以设计这样一个类来表示事件，用topic表示消息类型，用entityTpye和entityId来定位评论或者帖子，用entityUserId来表示实体的所有者，userId来表示这个事件是谁触发的。data是用于存储其他信息的。
我们注意到这个类中的setter方法的返回值都是实体，这是因为在设置值的时候比较方便，可以连续使用set方法。

生产者就是消息的产生者，在我们的业务中，就是当发送评论、点赞和关注时将消息放入特定的主题队列中等待消费者消费即可。在SpringBoot中我们可以使用KafkaTemplate类的实例很方便的实现生产者方法。

我们使用fireEvent方法来封装KafkaTemplate的send方法，send方法就是向指定的topic队列中发送一个消息，这里我们发送的是event对象转成json之后的字符串。

在SpringBoot中我们使用@KafkaListener来实现对消息队列的监听，当收到消息时就会触发相应的方法，我们使用ConsumerRecord类的实例来接收消息队列中的消息。

在我们的业务中，我们首先判断是否由收到消息，然后把收到的消息字符串转换为Event对象，然后我们将该消息经过处理存储到message数据库中。

在message数据表中，我们设置消息的发送者id为系统ID，消息的接收者id为event的entityUserId,消息的会话Id我们可以设置为事件的主题，而消息的内容我们可以用一个map来存储，需要放入event的userId,entityType和entityId，如果data中有数据我们也要放入其中。然后把map转成json格式的字符串放入数据库中。

这里，我们以评论为例。当增加评论的时候，我们需要将该消息加入到消息队列中，因此我们需要声明Event实例。对于评论我们设置主题为comment，设置用户id为当前发表评论的用户id，设置实体的种类和id都是当前评论目标的目标的种类和id，然后在data中我们要传入当前帖子的id，方便查看详情时定位到该帖子。对于评论对象的不同，我们使用不同的service来查询不同的实体得到entityUserId。当声明好事件之后，我们就可以调用生产者来发送消息了。

### 发送系统通知

在 `CommunityConstant` 接口中新增三个常量，代表三个主题：评论、点赞、关注。

创建 `Event` 类，封装事件对象，包括主题、用户 `id`、实体类型、实体 `id`、实体用户 `id` 以及一个 map 集合存放其它信息。

通知这一部分，关于何时通知，当别人评论你的帖子，别人回复你的评论，别人点赞你的实体（帖子评论），别人关注了你的时候。因为用的是同一张表，这时候`from_id`变为1，`conversation_id`为发起通知类型。`content`
字段不在存储字符串，而是存放json字符串包含用户`id`、实体`id`、实体类型、帖子`id`。用来表明是什么类型的信息、发生在什么时候。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407202055.png)

#### 触发事件

创建 `EventProducer` 事件生产者，新增 `fireEvent(Event event)` 方法，通过 `Event` 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 `KafkaTemplate`
实例的 `send` 方法发送。

在 `CommentController`、`LikeControler`、`FollowController` 中注入 `EventProducer` 实例，分别重构 `addComment` 方法、`like` 方法、`follow`
方法，封装 `Event` 对象，然后调用 `EventProducer` 的`fireEvent` 方法发布通知。

#### 消费事件

创建 `EventConsumer` 事件消费者，消费者是被动触发的。

- 注入 `MessageService` 实例。
- 增加 `handleCommentMessage(ConsumerRecord record)` 方法，通过 `@KafkaListener` 注解，`topic` 包括了评论、点赞和关注。从 `recored`
  中获取信息，封装成 `Message` 对象然后调用 `addMessage` 方法插入数据库。

### 显示系统通知

#### 通知列表

在 `MessageMapper` 接口中

- 新增 `selectLatestNotice(int userId, String topic)` 方法，查询某主题最新的通知。
- 新增 `selectNoticeCount(int userId, String topic)` 方法，查询某主题通知的数量。
- 新增 `selectNoticeUnreadCount(int userId, String topic)` 方法，查询未读通知的数量。
- 在 `MessageMapper.xml` 配置三个方法的 sql 语句，其中查询未读通知时使用 `if` 动态语句，如果没有传入 `topic` 就查询未读总量。

- 在业务层的 `MessageService` 中
  - 新增 `findLatestNotice` 方法，调用 `selectLatestNotice` 方法查询最新通知。
  - 新增 `findNoticeCount` 方法，调用 `selectNoticeCount` 方法查询某主题通知的数量。
  - 新增 `findNoticeUnreadCount` 方法，调用 `selectNoticeUnreadCount` 方法查询未读通知的数量。

- 在表现层的 `MessageController` 中新增 `getNoticeList` 方法，获取通知列表
  - 调用业务层 `MessageService` 的方法查询评论、点赞、关注的通知，将其封装在一个 `HashMap` 集合中然后添加到 `Model` 对象里。
  - 调用业务层 `MessageService` 的方法查询私信和通知的总未读数量，添加到 `Model` 对象里。
  - 返回 `notice.html` 页面。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407202113.png)

#### 显示通知详情

在 `MessageMapper` 接口新增 `selectNotices` 方法，查询某个主题的通知列表，在 `MessageMapper.xml` 配置 SQL。

- 在业务层的 `MessageService` 中新增 `findNotices` 方法，调用 `selectNotices` 方法。
- 在表现层的 `MessageController` 中新增 `getNoticeDetail` 方法
  - 调用 `findNotices` 方法获取通知列表详情，封装到 `List` 集合并存入 `Model` 对象。
  - 从通知集合中获取 `id` 集合，调用 `readMessage` 方法将消息设为已读。
  - 返回 `notice-detail.html` 页面。

#### 显示未读通知总数

显示通知的逻辑和显示私信的逻辑类似。

然后要多加一个拦截器用于计算用户未读消息的数量（私信+系统通知），因为在导航栏中因此可以加入到拦截器中，这样用户在线时收到消息就能及时看到（去别的页面就可以）

- 创建 `MessageInterceptor` 拦截器
  - 注入 `MessageService` 实例和 `HostHolder` 实例。
  - 重写 `postHandle` 方法，查询私信和通知的未读数量和，然后添加到 `ModelAndView` 对象。
- 在 `WebConfig` 中注入 `MessageInterceptor` 实例，并在 `addInterceptors`ƒ 方法中添加该拦截器。

## Elasticsearch

### 开发社区搜索功能

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210424101524.png)

## `Spring Quartz`实现定时热帖排行

我们何时进行计算，首先每个帖子在更新时进行计算肯定是没有必要的，因为这样对服务器压力太大了，比如一个热帖同时有100人点赞，那服务器就要计算100边，但是用到的只有最后一个结果。

因此，我们可以采用定时任务的方式进行，比如每隔一小时计算一次，因此我们需要确定的是哪些帖子需要进行计算，对其用redis进行缓存起来，所用的类型很显然是`set`，因为需要去重，并且不要求顺序。

在计算完成之后，我们需要更新`mysql`的数据、`elasticsearch`的数据。

首先，我们定义存储帖子的`redis`的`key`，采用`post:score`的键，然后所有需要计算的帖子放入即可。

由于热帖排行功能的实现是需要定时实现的，即每隔段时间就要从数据库中查询最热门的帖子显示，所以可以使用定时任务的形式来实现，JDK自带的`ScheduledExecutorService`
以及Spring自带的`ThreadPoolTaskScheduler`都可以实现定时任务的功能，但是其在分布式的环境下会出现问题，`Scheduler`是基于内存，服务器1和服务器2的上的`Scheduler`
代码是相同的，会定时的做同样的事情。本项目采用的是`Quartz`，因为`quartz`实现定时任务的参数是存到数据库中的，所以不会出现重复代码的问题。

JDK线程池

- `ExecutorService`
- `ScheduledExecutorService`
  Spring线程池
- `ThreadPoolTaskExecutor`
- `ThreadPoolTaskScheduler`
  分布式定时任务
- `Spring Quartz`

使用Quartz，不同服务器的Scheduler运行时，会在数据库服务器访问运行数据，通过排队（加锁），可以使得程序只运行一次。

`Job`:定义任务

`JobDetail`、`trigger` :任务的配置类，一旦任务初始化完成就会存到数据库的表中`qrtz_triggers`，只在第一次时有用

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210408043820.png)

帖子排行的计算公式： **log（评论数 10 + 点赞数 2 ）+ （发布时间 - 纪元）

将分数发生变换的帖子丢到`Redis`缓存中去，每10分钟计算一下帖子的分数。

key:post:score

value:set(存帖子id）

quartz有三个要素，分别是Schedule、Trigger和JobDetail+Job

- `Scheduler`：调度器。所有的调度都是由它控制。
- `Trigger`： 触发器。决定什么时候来执行任务。
- `JobDetail & Job`： `JobDetail`定义的是任务数据，而真正的执行逻辑是在`Job`中。使用`JobDetail + Job`而不是`Job`，这是因为任务是有可能并发执行，如果`Scheduler`
  直接使用`Job`，就会存在对同一个`Job`实例并发访问的问题。而`JobDetail & Job` 方式，`sheduler`每次执行，都会根据`JobDetail`创建一个新的`Job`实例，这样就可以规避并发访问的问题。

quartz能够在分布式的时候很好地解决就是因为引入了数据库，这样就能做到数据同步了。具体分布如下

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210408060521.png)

## 优化网站的性能

- 本地缓存
  - 将数据缓存在应用服务器上，性能最好，如Guava，Caffeine
- 分布式缓存
  - 将数据缓存在NoSQL数据库上，跨服务器，如Redis
- 多级缓存
  - 一级缓存(本地缓存) -> 二级缓存(分布式缓存) ->DB
  - 避免缓存雪崩(缓存失效，大量请求直达DB)，提高系统可用性

在我们的项目中我们主要使用`LoadingCache`，是一个同步缓存会阻塞的接口。声明两个分别表示帖子列表的缓存和帖子总数的缓存列表的`LoadingCache`实例。

只有当查询首页的热门帖子时才使用缓存，如果没有查到会调用其`load`方法同步数据，这是阻塞的。

接下来，我们就来初始化帖子列表的缓存，我们可以在`@PostConstruct`注解标注的`init()`方法中初始化。我们使用`Caffeine`提供的`newBuilder()`
方法来设置缓存的最大容量和过期方式和时间，然后在`build()`中匿名实例化一个`CacheLoader`对象即可。在该方法中我们首先检查`key`是否合法，合法的话就得到`offset`和`limit`
，然后这里我们使用二级缓存的方式，`caffeine->redis->DB`这样的方式。

因此，当本地缓存不存在的时候，我们先去`redis`里查，如果`redis`里没有就去数据库里查到需要的数据，然后存入`redis`并设置过期时间，然后返回该数据即可，`caffeine`会将该数据作为缓存进行同步。如果`redis`
中有，首先查看是否过期，如果过期了也是从数据库里查询然后同步到`redis`和`caffeine`中，如果没有过期就将`redis`中的数据作为结果返回。

`redis`对于过期数据的处理一般是惰性删除，即过期之后不立刻删除，等到下次读/写的时候才会将数据删除，因此其实可以不用写过期之后的处理，同没有该`key`是一样的，但是为了逻辑的完善还是写上去了。

```java
postListCache=Caffeine.newBuilder()
        .maximumSize(maxSize)
        .expireAfterWrite(expireSeconds,TimeUnit.SECONDS)
        .build(new CacheLoader<String, List<DiscussPost>>(){
@Nullable
@Override
public List<DiscussPost> load(@NonNull String key)throws Exception{
        if(key==null||key.length()==0){
        throw new IllegalArgumentException("参数错误！");
        }
        String[]params=key.split(":");
        if(params==null||params.length!=2){
        throw new IllegalArgumentException("参数错误！");
        }
        int offset=Integer.valueOf(params[0]);
        int limit=Integer.valueOf(params[1]);

        // 二级缓存：Redis -> mysql
        String redisKey=RedisKeyUtil.getHotPostListKey(offset,limit);
        // 如果redis中不存在就去数据库里查，查到了就更新到redis中，然后返回作为本地缓存的同步
        if(!redisTemplate.hasKey(redisKey)){
        logger.debug("redis中没有缓存");
        logger.debug("load post list from DB.");
        List<DiscussPost> result=discussPostMapper.selectDiscussPosts(0,offset,limit,1);
        for(DiscussPost post:result){
        redisTemplate.opsForZSet().add(redisKey,post,post.getScore());
        }
        redisTemplate.expire(redisKey,15,TimeUnit.SECONDS);
        return result;
        }else{
        logger.debug("redis中有缓存");
        // 要查看redis数据是否过期
        System.out.println(redisTemplate.getExpire(redisKey));
        boolean isExpired=redisTemplate.getExpire(redisKey)< 0?true:false;
        if(isExpired){
        // 如果过期的话，就删去key，就去数据库里查
        logger.debug("redis expired!");
        redisTemplate.delete(redisKey);
        logger.debug("load post list from DB.");
        List<DiscussPost> result=discussPostMapper.selectDiscussPosts(0,offset,limit,1);
        for(DiscussPost post:result){
        redisTemplate.opsForZSet().add(redisKey,post,post.getScore());
        }
        redisTemplate.expire(redisKey,7*60,TimeUnit.SECONDS);
        return result;
        }else{
        Set<DiscussPost> posts=redisTemplate.opsForZSet().reverseRange(redisKey,offset,limit);
        logger.debug("redis len: "+redisTemplate.opsForZSet().zCard(redisKey));
        logger.debug("load post list from redis.");
        List<DiscussPost> list=new ArrayList<>();
        for(DiscussPost post:posts){
        list.add(post);
        }
        return list;
        }
        }
        }
        });
```

使用`Redis`缓存用户信息:

- 处理每次请求的时候，都要根据登录凭证查询用户信息，访问的评率非常高（每次请求的时候需要根据凭证中的用户`id`查询用户）
- 查询`User`的时候，先尝试从缓存中取值，如果没有的话，就需要初始化，有些地方会改变用户数据，需要更新缓存，可以直接把该用户的缓存删除，下一次请求的时候发现没有用户的信息，就会重新查一次再放到缓存中

## 项目发布

客户端的请求一般由Nginx反向代理接收，而Nginx服务器至少部署两台，保证在主服务器挂掉的情况下，也有服务器能够进行反向代理

而网站的静态资源一般放在CDN

一般业务服务器会部署多台，

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407212640.png)

## 相关问题

- 什么是Spring框架？

  有很多模块组成，利用这些模块可以方便开发工作。这些模块是：核心容器（spring core)/数据访问和集成(Spring JDBC)/Web(Spring Web/MVC)/AOP(Spring Aop)/消息模块/测试模块(
  Spring Test)等。

- 对Spring IoC的理解

IoC的意思是控制反转，是一种设计思想，把需要在程序中手动创建对象的控制权交给了Spring框架。IoC的载体是IoC容器，本质是一个工厂，数据结构上来看是一个Map，用来存放着各种对象。当我们创建一个对象时，只需要配置好配置文件/注解，而不用担心对象是怎么被创建出来的。

IoC的优点：降低耦合，对象被容器管理需要两份数据：你的对象定义 + 配置文件，对象间的关系体现在配置文件，不会直接产生耦合。

- 什么是DAO

data access object，存放数据库访问对象。

- Spring中关于Bean的注解

四种常见Bean:@Controller @Repository @Service @Component一般来说Bean只会被容器初始化一次，@PostConstruct：初始化前调用 @PreDestroy：销毁之前

- 如何使用Bean

bean通过容器管理，不需要我们实例化，如果要使用某个bean，使用依赖注入 @Autowired

- Spring MVC是什么，是怎样的工作流程

服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)
，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。

1. 客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)
2. DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler。
3. 查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理
4. HandlerAdapter根据Handler来调用真正的Controller
5. Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View
6. ViewResolver根据逻辑view找到实际view
7. DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者

C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。

M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。

V - View：视图。返回给客户看的结果。

- 什么是SSM框架？

包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）

- 怎么实现注册功能的？

根据请求来拆解功能

1. 打开注册网页
2. 把注册的信息发送给服务器（点注册）
3. 把激活邮件发送给邮箱
4. 利用激活链接打开网页

每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层

- 什么是`Interceptor`，在项目的哪里使用到了`Interceptor`?

Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查`request`中的`login_ticket`，把找到的`user`
信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）

- 使用什么技术生成验证码

使用Kaptcha包，可随机生成字符和图片。

- 如何检查登陆状态

加拦截器注解。

- 如何实现敏感词过滤

使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。

- 什么是Ajax，应用在项目哪些地方？

ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。

项目中：帖子发布成功/失败的提示，使用到ajax

- 什么是事务，事务的四大特性。

定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。

ACID：

A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。 C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。 I
：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。 D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。

- 在并发环境下，并发事务会出现哪些问题？

脏读：事务A读到了事务B修改但未提交的数据。

丢失修改：事务A和事务B同时读取了某一数据，并进行减１，此数据最终只会减一。

不可重复读：事务A多次读取某数据时，发现前后不一致（被事务B修改了）

幻读：和不可重复读类似，事务A读取到几行数据，事务B此时插入数据，随后的查询中，事务A发现了一些原本不存在的数据。（不是读取）

- 介绍SQL的四个隔离级别
  `READ-UNCOMMITED`(读取未提交）:会出现脏读，不可重复读，幻读。

`READ-COMMITED`:会出现不可重复读，幻读

`REPETABLE-READ`:会出现幻读

`SERIALIZABLE`:都不会出现

- 怎么利用Spring实现事务管理

Spring管理事务忽略了底层数据库的结构，非常方便。有两种方式：注解（类型，传播方式）/编程式事务（override)。

- 是怎样实现统一捕获异常的？

在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层(`controller`)统一处理错误即可。

方法：在`controller`中加上`advice`包，并通过注解`@ControllerAdvice`和`@ExceptionHandler`，统一捕获异常。

- 是怎样实现统一记录日志的？

使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。
AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。
SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。

- 什么是`Redis`，`Redis`有哪些优点？

概念：redis是一个非关系型数据库，数据存储在内存中，读写速度快。可以存储键和五种不同类型值的映射。只能以字符串为键，值支持：字符串，列表，无序集合，有序集合，hash散列表。
优点：由于数据存储在内存中，读写速度非常快，满足高性能，高并发的系统要求。与Java原生的map/guava相比，支持分布式缓存。与memcached相比，支持更丰富的数据类型，且支持数据持久化。

- Redis分布式集群架构

典型的分片+复制

- 怎么往Spring框架中配置redis，介绍常见的redis操作

如何配置：

1. 导入jar包
2. 配置端口，以及配置类`redisTemplate`（注入连接工厂/设置序列化方式（json））

常见操作:

`Value`类型：`redisTemplate.opsForValue().set(redisKey, 1)`，`redisTemplate.opsForValue().get(redisKey)`
， `redisTemplate.opsForValue().increment(redisKey)`，

`Hash`类型：`redisTemplate.opsForHash().put(redisKey, “id”, 1)`， 还有`get`等操作

`List`类型：`redisTemplate.opsForList().leftPush(redisKey, 101)`， 还有`size`, `index`, `range`， `leftPop`等操作

`Set`类型：`add`,`size`,`pop`,`members`等操作

`Zset`类型：`redisTemplate.opsForZSet().add(redisKey, “Linda”, 92)`, 有`socre`，`rank`，`reverseRank`，`range`等操作

操作`key`：可以`delete`，以及设置过期时间

同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）

为什么不包含查询：`redis`事务就是一系列命令的批量操作，批量操作在发送 `EXEC` 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

- 怎样存储的点赞/关注/缓存用户数据

点赞使用`set`类型存储，`key`为点赞对象，`set`中保存点赞人的ID

关注使用`zSet`类型存储，`key`为被关注者，`set`保存关注者以及关注时间为`score`

缓存用户数据使用`Value`类型，`key`为用`userID`得到的`key`，`value`为`user`对象（设置过期时间，且数据修改时需要清除缓存）

- 什么是消息队列

消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：

1. 解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。
2. 异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。
3. 限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。

- 消息队列作为信息传递的中间件，需要注意哪些问题？

1. 高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式/集群的现成支持）
2. 数据持久化：防止数据丢失
3. 如何取数据：消息队列主动通知或者消费者轮询。

- Java中的`blockingqueue`，可以提供线程间的消息队列

BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）`Blocking Queue`构建了一个桥梁，能够解决生产速度/消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。

- 什么是`Kafka`，有哪些功能和应用场景？

`Kafka`为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。

`Kafka`主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。

- Kafka的消息模型，以及常见术语

消息模型：发布-订阅模型，消费者订阅了某一主题（`topic`）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。

`Topic`：主题，类似于文件夹，用来存放不同的数据。

`Partition`：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。

`Offset`：消息在`Partition`中的存放位置。

`Broker`：可以理解为`kafka`集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着`topic1`的`leader`， `topic2`的`follower`等等。

- 在项目哪里用到了`Kafka`

当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了`Kafka`，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的`Controller`
使用，产生消息。而消费者负责消息（`message`）到来时，把消息存到数据库内。

- 什么是`Caffeine`，如何缓存，项目应用

概念：`Caffeine` 是一个基于Java 8的高性能本地缓存框架

初始化cache：缓存保存的对象，使用`Caffeine.newBuilder()`创建，创建时设置缓存大小，过期时间，缓存未命中时的加载方式。

为什么只缓存热度帖子？不会经常变。

### MySQL

* 存储引擎
  * InnoDB支持事务（Transations）
* 事务
  * 事务的特性：原子性、一致性、隔离性、持久性
  * 事务的隔离
    * 并发异常：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读
    * 隔离级别：Read Uncommited、Read Committed、Repeatable Read、Serializable
    * Spring事务管理：声明式事务、编程式事务
* 锁
  * 范围
    * 表级锁：开销小、加锁快，发生锁冲突的概率高、并发度低，不会出现死锁。
    * 行级锁：开销大、加锁慢，发生锁冲突的概率低、并发度高，会出现死锁。
* 索引（InnoDB）
  * 共享锁（S）：行级，读取一行；
  * 排他锁（X）：表级，更新一行；
  * 意向共享锁（IS）：表级，准备加共享锁；
  * 意向排他锁（IX）：表级，准备加排他锁；
  * 间隙锁（NK）：行级，使用范围条件时，对范围内不存在的记录加锁。一是为了防止幻读，二是为了满足恢复和复制的需要。

| | IS | IX | S | X | | :--: | :--: | :--: | :--: | :--: | | IS | | | | x | | IX | | | x | x | | S | | x | | x | | X | x
| x | x | x |

* 加锁

  * 增加行级锁之前，InnoDB会自动给表加意向锁；
  * 执行DML语句时，InnoDB会自动给数据加排他锁；
  * 执行DQL语句时
    * 共享锁（S）：SELECT...FROM...WHERE...LOCK IN SHARE MODE;
    * 排他锁（X）：SELECT...FROM...WHERE...FOR UPDATE;
    * 间隙锁（NK）：上述SQL采用范围条件时，InnoDB对不存在的记录自动增加间隙锁。

* 死锁

  * 场景
    * 事务1：UPDATE T SET...WHERE ID=1;UPDATE T SET...WHERE ID=2;
    * 事务2：UPDATE T SET...WHERE ID=2;UPDATE T SET...WHERE ID=1;
  * 解决方案
    * 一般InnoDB会自动检测到，并使一个事务回滚，另一个事务继续；
    * 设置超时等参数 innodb_lock_wait_timeout；
  * 避免死锁
    * 不同的业务并发访问多个表时，应约定以相同的顺序来访问这些表；
    * 以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理数据；
    * 在事务中，如果要更新记录，应直接申请足够级别的锁，即排他锁；

* 悲观锁（数据库）

* 乐观锁（自定义）

  * 版本号机制

    * UPDATE..SET...,VERSION=#{version+1} WHERE ... AND ... VERSION=#{version}

  * CAS算法（Compare and swap）

    是一种无锁的算法，该算法涉及3个操作数（内存值V、旧值A、新值B），当V等于A时，采用原子方式用B的值更新V的值。该算法通常采用自旋操作，也叫自旋锁。它的缺点是：

    * ABA问题：某线程将A改为B，再改回A，则CAS会误认为A没被修改过。
    * 自旋操作采用循环的方式实现，若加锁时间长，则会给CPU带来巨大的开销。
    * CAS只能保证一个共享变量的原子操作。

* B+Tree(InnoDB)

  * 数据分块存储，每一块称为一页；
  * 所有值都是按顺序存储的，并且每一个叶子到根的距离相同；
  * 非叶子节点存储数据的边界，叶子节点存储指向数据行的指针；
  * 通过边界缩小数据的范围，从而避免全表扫描，加快了查找的速度。

### Redis

* 数据类型

|  数据类型   | 最大存储数据量 |
| :---------: | :------------: |
|     key     |      512M      |
|   string    |      512M      |
|    hash     |     2^32-1     |
|    list     |     2^32-1     |
|     set     |     2^32-1     |
| sorted set  |    官方没给    |
|   bitmap    |      512M      |
| hyperloglog |      12K       |

* 过期策略

  Redis会把设置了过期时间的key放入一个独立的字典里，在key过期时并不会立刻删除它。

  Redis会通过如下两种策略，来删除过期的key：

  * 惰性删除

    客户端访问某个key时，Redis会检查该key是否过期，若过期则删除。

  * 定期扫描

    Redis默认每秒执行10次过期扫描（配置hz选项），扫描策略如下：

    1. 从过期字典中随机选择20个key；
    2. 删除这20个key中已过期的key；
    3. 如果过期的key的比例超过25%，则重复步骤1；

* 淘汰策略

  当Redis占用内存超出最大限制（maxmemory）时，可采用如下策略（maxmemory-policy），让Redis淘汰一些数据，以腾出空间继续提供读写服务：

  * noeviction：对可能导致增大内存的命令返回错误（大多数写命令，DEL除外）；
  * volatile-ttl：在设置了过期时间的key中，选择剩余寿命（TTL）最短的key，将其淘汰；
  * volatile-lru：在设置了过期时间的key中，选择最少使用的key（LRU），将其淘汰；
  * volatile-random：在设置了过期时间的key中，随机选择一些key，将其淘汰；
  * allkeys-lru：在所有的key中，选择最少使用的key（LRU），将其淘汰；
  * allkeys-random：在所有的key中，随机选择一些key，将其淘汰；

  LRU算法：

  * 维护一个链表，用于顺序存储被访问过的key。在访问数据时，最新访问过的key将被移动到表头，即最近访问的key在表头，最少访问的key在表尾。

  近似LRU算法（Redis）

  * 给每个key维护一个时间戳，淘汰时随机采样5个key，从中淘汰掉最旧的key。如果还是超出内存限制，则继续随机采样淘汰。
  * 优点：比LRU算法节约内存，却可以取得非常近似的效果。

* 缓存穿透

  * 场景

    查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。

  * 解决方案：

    1. 缓存空对象：存储层未命中后，仍然将空值存入缓存层。再次访问该数据时，缓存层会直接返回空值。
    2. 布隆过滤器：将所有存在的key提前存入布隆过滤器，在访问缓存层之前，先通过过滤器拦截，若请求的是不存在的key，则直接返回空值。

* 缓存击穿

  * 场景

    一份热点数据，它的访问量非常大。在其缓存失效瞬间，大量请求直达存储层，导致服务崩溃。

  * 解决方案：

    1. 加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被 重建，届时其他线程就可以直接从缓存取值。
    2. 永不过期：不设置过期时间，所以不会出现上述问题，这是“物理“上的不过期。为每个value设置逻辑过期时间，当发现该值逻辑过期时，使用单独的线程重建缓存。

* 缓存雪崩

  * 场景

    由于某些原因，缓存层不能提供服务，导致所有请求直达存储层，造成存储层宕机。

  * 解决方案：

    1. 避免同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。
    2. 构建高可用的Redis缓存：部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。
    3. 构建多级缓存：增加本地缓存，在存储层前面多加一级屏障，降低请求直达存储层的几率。
    4. 启用限流和降级措施：对存储层增加限流措施，当请求超出限制时，对其提供降级服务。

* 分布式锁

  * 场景

    修改时，经常需要将数据读取到内存，在内存中修改后再存回去。在分布式应用中，可能多个进程同时执行上述操作，而读取和修改非原子操作，所以会产生冲突。增加分布式锁，可以解决此类问题。

  * 基本原理

    * 同步锁：在多个线程都能访问到的地方，做一个标记，标识该数据的访问权限。
    * 分布式锁：在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限。

  * 实现方式

    1. 基于数据库实现分布式锁；
    2. 基于Redis实现分布式锁；
    3. 基于Zookeeper实现分布式锁；

  * Redis实现分布式锁的原则

    1. 安全属性：独享。在任一时刻，只有一个客户端持有锁。
    2. 活性A：无死锁。即便持有锁的客户端崩溃或者网络被分裂，锁仍然可以被获取。
    3. 活性B：容错。只要大部分Redis节点都活着，客户端就可以获取和释放锁。

  * 单Redis实例实现分布式锁

    1. 获取锁使用命令：

       ```
       SET resource_name my_random_value NX PX 30000
       ```

       NX：仅在key不存在时才执行成功。PX：设置锁的自动过期时间。

    2. 通过Lua脚本释放锁：

       ```
       if redis.call("get",KEYS[1]) == ARGV[1] then 
       	return redis.call("del",KEYS[1])
       else return 0 end
       ```

       可以避免删除别的客户端获取成功的锁：

       A加锁 --> A阻塞 --> 因超时释放锁 --> B加锁 --> A恢复 --> 释放锁

  * 多Redis实例实现分布式锁

    Redlock算法，该算法有现成的实现，其Java版本的库为Redisson。

    1. 获取当前Unix时间，以毫秒为单位。
    2. 依次尝试从N个实例，使用相同的key和随机值获取锁，并设置响应超时时间。如果服务器没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
    3. 客户端使用当前时间减去开始获取锁的时间，得到获取锁使用的时间。当且仅当大多数的Redis节点都取到锁，并且使用的时间小于锁失效的时间时，锁才算取得成功。
    4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁使用的时间。
    5. 如果获取锁失败，客户端应该在所有的Redis实例上进行解锁。

### Spring

* Spring IOC
  * Bean的作用域

|    作用域     |    使用范围    |                             描述                             |
| :-----------: | :------------: | :----------------------------------------------------------: |
|   singleton   | 所有Spring应用 |               在容器中只存在一个实例，默认值。               |
|   prototype   | 所有Spring应用 | 在容器中存在多个实例，即每次获取该Bean时，都会创建一个新实例。 |
|    request    | SpringWeb应用  |                 为每个请求创建一个新的实例。                 |
|    session    | SpringWeb应用  |                 为每个会话创建一个新的实例。                 |
| globalSession | SpringWeb应用  |    为全局的session创建一个实例，只在Portlet上下文中有效。    |
|  application  | SpringWeb应用  |               为整个Web应用创建一个新的实例。                |

* Spring AOP

  * AOP的术语

    Target（Joinpoint）<-- Weaving <-- Aspect(Pointcut(s.find*(..))、Advice(q前、后、返回、异常))

    1. 编译时织入，需使用特殊的编译器。
    2. 装载时织入，需使用特殊的类装载器。
    3. 运行时织入，需为目标生成代理对象。

* Spring MVC

  1. **客户端**发出请求访问服务器时，由**DispatcherServlet**处理。
  2. DispatcherServlet调用**HandlerMapping**(根据访问路径找到对应Controller)。
  3. HandlerMapping给DispatcherServlet返回**HandlerExecutionChain**对象（封装了Controller和拦截器）。
  4. DispatcherServlet调用拦截器的preHandle()方法，接着调用**HandlerAdapter**(内部调了Controller)。
  5. HandlerAdapter返回**ModelAndView**给DispatcherServlet，返回后调用postHandle()方法。
  6. DispatcherServlet调用**ViewResolver**(视图解析器)。
  7. ViewResolver解析**View**，由模板引擎渲染，（拦截器的afterCompletion()方法）返回客户端。

### 分布式Session

在分布式部署中，为什么不使用session呢？

因为服务器是分布式部署的（承载大流量），浏览器访问的是服务器代替nginx，nginx按照负载均衡的原则分配请求。在多次请求的过程中，可能会有多台服务器处理同一个浏览器的请求，但session只保存在一台服务器中。

解决策略：

粘性session：浏览器只访问一个服务器。（负载不均衡）

同步session：每个服务器存的session都相同（性能降低，增大服务器的耦合性）

共享session：单独有一台服务器来存储session，当服务器需要使用session时，往这台服务器申请（这台服务器威胁到了整个集群）

常用解决方案：一般数据都使用cookie而不是session，必要重要的数据存到数据库（集群）（非关系型数据库redis）里。
