<!-- TOC -->

- [iCommunity](#icommunity)
  - [功能简介](#功能简介)
  - [主要技术：](#主要技术)
  - [数据库表](#数据库表)
    - [用户表(`user`)](#用户表user)
    - [评论表(`comment`)](#评论表comment)
    - [帖子表(`discuss_post`)](#帖子表discuss_post)
    - [用户登录凭证表(`login_ticket`)](#用户登录凭证表login_ticket)
    - [消息表(`message`)](#消息表message)
  - [开发社区首页](#开发社区首页)
    - [搭建基本环境](#搭建基本环境)
    - [开发社区首页(`discuss_post` 表)](#开发社区首页discuss_post-表)
      - [开发数据层](#开发数据层)
    - [开发业务层](#开发业务层)
    - [开发视图层](#开发视图层)
    - [开发分页组件](#开发分页组件)
  - [开发注册登录模块](#开发注册登录模块)
    - [发送邮件](#发送邮件)
    - [注册功能](#注册功能)
    - [生成验证码](#生成验证码)
    - [登录退出功能(`login_ticket` 表)](#登录退出功能login_ticket-表)
    - [显示登录信息](#显示登录信息)
    - [上传头像](#上传头像)
    - [检查登录状态](#检查登录状态)
  - [开发核心功能](#开发核心功能)
    - [敏感词过滤](#敏感词过滤)
    - [发布帖子](#发布帖子)
    - [显示帖子内容](#显示帖子内容)
    - [显示评论(`comment` 表)](#显示评论comment-表)
    - [添加评论](#添加评论)
    - [显示私信列表(`message`表)](#显示私信列表message表)
    - [发送私信](#发送私信)
    - [统一异常处理](#统一异常处理)
    - [统一日志处理](#统一日志处理)
  - [Redis](#redis)
    - [点赞](#点赞)
    - [收到的赞](#收到的赞)
    - [关注](#关注)
    - [个人主页](#个人主页)
    - [关注列表和粉丝列表](#关注列表和粉丝列表)
    - [优化登录模块](#优化登录模块)
      - [存储验证码](#存储验证码)
      - [存储登录凭证](#存储登录凭证)
      - [缓存用户信息](#缓存用户信息)
    - [热帖排行](#热帖排行)
  - [Kafka](#kafka)
    - [发送系统通知](#发送系统通知)
      - [触发事件](#触发事件)
      - [消费事件](#消费事件)
    - [显示系统通知](#显示系统通知)
      - [通知列表](#通知列表)
      - [显示通知详情](#显示通知详情)
      - [显示未读通知总数](#显示未读通知总数)
  - [Elasticsearch](#elasticsearch)
    - [开发社区搜索功能](#开发社区搜索功能)
  - [优化网站的性能](#优化网站的性能)
  - [项目发布](#项目发布)
  - [相关问题](#相关问题)

<!-- /TOC -->

# iCommunity

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407204344.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407210435.png)

## 功能简介

一个仿照牛客网实现的讨论社区，不仅实现了基本的注册，登录，发帖，评论，点赞，回复功能，同时使用前缀树实现敏感词过滤，使用wkhtmltopdf生成长图和pdf，实现网站UV和DAU统计，并将用户头像等信息存于七牛云服务器。

自学项目。开发仿牛客网社区，实现注册、登录、修改信息、发帖、评论、点赞、关注等功能。

## 主要技术：

- 利用 `ThreadLocal` 保存用户状态，通过拦截器拦截请求，根据自定义注解判断用户登录状态。
- 使用 Ajax 异步发帖、发送私信、评论，通过字典树过滤敏感词。
- 使用 Redis 实现点赞、关注功能，优化登录模块——存储登录凭证、缓存用户信息、存储 kaptcha 生成的验证码。

- 完成了用户登录注册模块, 使用拦截器实现了统一的登录状态验证，期间学习到了Cookie、Session、JWT等身份认证相关的技术
-

- 使用`Spring Security` 做权限控制，替代拦截器的拦截控制，并使用自己的认证方案替代`Security` 认证流程，使权限认证和控制更加方便灵活。
- 使用`Redis`的`set`实现点赞，`zset`实现关注，并使用`Redis`存储登录`ticket`和验证码，解决分布式`session`问题。
- 使用`Redis`高级数据类型`HyperLogLog`统计`UV(Unique Visitor)`,使用`Bitmap`统计`DAU(Daily Active User)`。
- 使用`Kafka`处理发送评论、点赞和关注等系统通知，并使用事件进行封装，构建了强大的异步消息系统。
- 使用`Elasticsearch`做全局搜索，并通过事件封装，增加关键词高亮显示等功能。
- 对热帖排行模块，使用分布式缓存`Redis`和本地缓存`Caffeine`作为多级缓存，避免了缓存雪崩，将QPS提升了20倍(10-200)，大大提升了网站访问速度。并使用`Quartz`定时更新热帖排行。

## 数据库表

### 用户表(`user`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| username | varchar | 用户名，创建索引 |
| password | varchar | 用户密码 |
| salt | varchar | 加密盐值 |
| email | varchar | 用户邮箱，创建索引 |
| type | int | 用户类型：0 普通、1 管理员、2 版主 |
| status | int | 用户状态：0 未激活、1 已激活 |
| activation_code | varchar | 激活码 |
| header_url | varchar | 用户头像地址 |
| create_time |    timestamp | 注册时间 |

### 评论表(`comment`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| user_id | int | 评论的用户 id，创建索引 |
| entity_id | int | 评论实体 id，创建索引 |
| entity_type | int | 评论实体类型：1 帖子评论、2 评论回复 |
| target_id | int | 评论目标 id |
| content | text | 评论内容 |
| status | int | 评论状态：0 有效、1 无效 |
| create_time | timestamp | 评论发表时间 |

### 帖子表(`discuss_post`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| user_id | int | 评论的用户 id，创建索引 |
| title | varchar | 帖子表标题 |
| content | text | 帖子内容 |
| type | int | 帖子类型：0 普通、1 置顶 |
| content | text | 评论内容 |
| comment_count     | int | 评论数量 |
| status | int | 帖子状态：0 普通、1 精华、2 拉黑 |
| create_time | timestamp | 评论发表时间 |

### 用户登录凭证表(`login_ticket`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| user_id | int | 登录用户 id |
| ticket | varchar | 登录凭证，随机字符串 |
| status | int | 登录状态：0 有效、1 无效 |
| expired | timestamp | 过期时间 |

### 消息表(`message`)

| 字段 | 类型 | 备注 |
| :----:| :----: | :----: |
| id | int | 主键、自增 |
| from_id | int | 发消息的 id，创建索引 |
| to_id | int | 收消息的 id，创建索引 |
| conversation_id | varchar | 会话 id，由通信双方 id 拼接，创建索引 |
| content | text | 消息内容 |
| status | int | 消息状态：0 未读、1 已读、2 删除 |
| create_time | timestamp | 消息发送时间 |

## 开发社区首页

封装帖子实体类，还有用户实体类，还有`Page`页面类，我们根据帖子查询。
### 搭建基本环境

构建 SpringBoot 的 maven 项目，引入 mysql 和 mybatis 依赖。

在 `application.properties` 配置文件中：

- 关闭 thymeleaf 缓存
- 配置数据库，设置基本连接信息、最大线程数，最小空闲线程数，最大空闲时间等
- mybatis，设置 mapper 文件的位置、实体类包名、使用主键等
- 创建 community 数据库和数据库表。

用户相关操作：

- 创建对应 user 表的 `User` 实体类
- 创建 `UserMapper` 接口，使用 `@Mapper` 注解
- 创建 `UserMapper.xml`，重复 sql 语句可以写在 `<sql id = "xxx">` 标签，通过 `<include refid="xxx"/>` 引用。

### 开发社区首页(`discuss_post` 表)

功能拆分：开发社区首页，显示前 10 个帖子。开发分页组件，分页显示所有帖子。

用到的表是 `discuss_post` 数据库表，包括帖子 `id`、发帖人 `id`、标题、内容、类型、状态、发帖时间、评论数量（为了提高效率，避免关联查询，因此冗余存储）、分数（用于进行热度排名）。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201321.png)

#### 开发数据层

帖子相关操作：

- 创建对应 `discuss_post` 表的 `DisscussPost` 实体类。

- 创建 `DisscussPostMapper 接口`，使用 `@Mapper` 注解。

  - 分页查询中用户 `id` 是可选参数，通过动态 SQL 选择，如果为 0 就不使用，在开发用户个人主页查询用户发帖记录时需要使用。
  - 如果只有一个参数，并且在动态 SQL 的 `<if>` 里使用，必须使用 `@Param` 加别名。
- 创建 `DisscusspostMapper.xml`。
  - `where status != 2` :拉黑的帖子不展现。
  - `<if test="userId!=0">`: `userID` 为 0 时不使用，按照类型，发帖时间排序。

### 开发业务层

- 创建 `DiscussPostService` 类，可以分页查询帖子和帖子数量。
- 创建 `UserService` 类，实现根据 `id` 查询用户功能，因为显示帖子时不显示用户 `id`，而是显示用户名。

### 开发视图层

- 把静态资源 css、html、img、js 放到 `static` 目录下。
- 把模板 mail、site、`index.html` 放到 `template` 目录下。
- 创建 `HomeController`，`getIndexPage` 方法，用 map 集合把帖子和用户封装到一起。
- 修改 `index.html`，使用 `<th:text="${map.xxx.xxx}"` 动态替换。

### 开发分页组件

- 创建 `Page` 实体类，封装分页信息，包括当前页码、显示限制、帖子总数、查询路径等。显示的起始页不能小于 1，最大页不能超过 `total`。
- 在 index.html 中，当 `page.rows > 0` 时显示分页信息。
- 如果 `page.current` 等于 1 或 `page.total`，代表是首页或末页，此时不能点击上一页和下一页，用 `disabled` 属性实现。

## 开发注册登录模块

验证码：浏览器先`get`请求验证码，服务端在`cookie`中添加信息验证这是同一人输入的验证码（在`redis`与浏览器中设置过期信息）

登录：登录后在`cookie`中添加`ticket`，浏览器每次都带着`ticket`来请求，服务端获取去和`redis`中的比对，成功就使用`threadlocal`去持有这个用户的信息。返回页面结束后就移除这个用户的信息。

问题：如果要保证同一时间只能有一个用户登录呢？

我的想法是维护一个`map`, 键为用户`id`，值为`ticket`的。每次浏览器带着`ticket`来请求，从`ticket`中取出用户`id`和`map`中的比对,如果不同则说明了有人后面登录这个账号，然后把`redis`
中的这个`ticket`删除，重定向到登录页面。

### 发送邮件

- 在网易邮箱打开 SMTP 服务。
- 引入 spring-boot-starter-mail 依赖。
- 在配置文件配置主机、端口、发送邮箱、授权码等。
- 创建 `MailClient` 类，调用 `JavaMailSender` 发送邮件。
- 使用 thymeleaf 发送 HTML 邮件，调用 `TemplateEngine` 把信息封装到 HTML 模板。

### 注册功能

- 把 `register.html` 地址关联到首页的注册 `href` 属性。
- 设置域名、创建 `CommunityUtil` 工具类，在工具类创建生产随机字符串和 MD5 加密方法。
- 创建 `LoginController`，创建 `getRegisterPage` 方法，跳转注册页面。
- 在 `UserService` 中创建 `register` 方法，判断注册信息合规后插入数据库，发送激活邮件。
- 在 `LoginController` 创建 `register` 方法，调用 `UserService` 的 `register` 方法。
- 创建接口 `CommunityConstant`，定义激活码的三种状态，成功、重复、失败，让 `UserService` 和 `LoginController` 实现该接口。
- 点击激活邮件的 `url` 【本地服务器的url】后，服务器通过 `LoginController` 的 `activation` 方法查询数据库用户，如果 `url` 中的激活码和设置的一样，就把用户 `status` 改为 1。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201343.png)

需要先开发验证码功能还有完成邮件工具类功能、

前期我们通过`session`存储验证码(后期通过`redis`改进系统性能)

验证了`session`跟前台的值是否匹配后，先查询数据库中是否已经存在当前用户名或者已经存在相同的邮箱等，如果符合条件，随机生成一个激活码注入到`user`中，然后则通过`Context`和`templateEngine`
访问邮件页，并将其转换为`String`格式发送给邮箱。(此处需要使用到激活需求)

当我们使用邮件传来的网址访问时，我们请求会访问数据库，将我们当前的账户激活。(激活页面会带有`userId`和`activationId`，会和发送邮件前在数据库中存储的信息进行比对，如果成功就设置`status`)

流程：

1. 写注册方法,返回值用map返回对应的消息。
2. 首先对传进来的user对象做一个空值的判断
3. 然后再验证账号和邮箱是否已注册过了
4. 再补全user对象的值，生成盐然后对密码进行加密
5. 注册用户都是普通用户，type设为0，状态设置为未激活0，再生成一个激活码随机字符串
5. 头像使用牛客网的默认头像，0-1000号头像都可以使用
6. 注册时间生成后插入对象就可以了
7. 最后用模板引擎生成html邮件，进行发送。

### 生成验证码

- 在 `pom.xml` 导入 kaptcha 的 jar 包。
- 创建配置类 `KaptchaConfig`，设置验证码的大小、范围、长度等。
- 在 `LoginController` 类新增 `getKaptcha` 方法生成验证码图片。
- 在 login.html 中，将刷新验证码的链接绑定 `refresh_kaptcha` 方法，通过 `id` 选择器获取 img 组件，重新访问 `getKaptcha` 方法生成验证码图片。
- 【问题】由于访问同一个生成验证码路径，需要在 `url` 参数加上一个随机数字，保证会重新请求获取新图片。

先保存在`session`，后续优化保存至`redis`

### 登录退出功能(`login_ticket` 表)

登录成功时，需要生成一个登录凭证发送给客户端。凭证可以在多个业务中连续地验证用户的登陆状态，凭证信息存储在 `login_ticket` 数据库表中，`status` 的 0 和 1 表示有效和无序，`expire` 表示过期时间。

- 创建对应 `login_ticket` 表的 `LoginTicket` 实体类，对应 `login_ticket` 数据库表。
- 创建 `LoginTicketMapper` 接口，通过 `@Insert`、`@Select`、`@Update` 注解来插入、查询、更新凭证。

- 在 `UserServce`

  - 创建 `login` 方法，验证账户合规后将凭证信息插入数据库，添加登录凭证到 map 中。
  - 创建 `logout` 方法，将对应凭证设为无效。

- 在 `LoginController`

  - 创建 `login` 方法，判断验证码正确后调用 `UserServce` 的 `login` 方法，如果 map 包含 `ticket` 代表登录成功，重定向跳转首页，否则添加错误信息并跳回登录页。
  - 创建 `logout` 方法，判断验证码正确后调用 `UserServce` 的`logout` 方法，跳转至登录页。

- 在 `login.html` 绑定登录链接，`index.html` 绑定退出登录链接。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201401.png)

验证前台的验证码与`session`中的验证码是否相符，如若不符，返回错误消息。

验证用户的账号与密码，如若没有此账号则返回没有此账号，如若是密码出错，我们则显示，密码错误返回给前台。如若都正确，我们就跳转至首页，并且存储一个登录凭证給数据库。我们如果点击退出登录，我们在数据库中的登录凭证就更改状态为1

### 显示登录信息

当用户登录过后，之后的请求都应该以登录态去访问，也就是每次带上`ticket`
，例如网站首页，登录和未登录的显示应该不同，如果我们按照正常逻辑，每个请求都得判断登录态，处理相关逻辑。而使用拦截器，则可以拦截浏览器的请求，再对其进行统一的处理。

定义好拦截器过后，我们还需要一个配置类对它进行配置。在`config`包下新建`WebMvcConfig`类，并实现`WebMvcConfigurer`接口。

注入拦截器，重写添加拦截器方法。

- `.excludePathPatterns`把静态资源排除在外，不进行拦截
- `.addPathPatterns`添加拦截路径


- 创建 `CookieUtil` 工具类，通过 `name` 查询对应 cookie 的 `value`。
- 在 `UserService` 中新增 `findLoginTicket` 方法，根据 `ticket` 查询 `LoginTicket`。
- 创建 `HostHolder` 类用来模拟 `session` 的功能，利用 `ThreadLocal` 实现，存储用户信息。
- 创建 `LoginTicketInterceptor` 拦截器，实现 `HandlerInterceptor` 接口。
  - 在 `preHandle` 方法中通过 `CookieUtil` 的 `getValue` 方法查询是否有凭证 `cookie`，如果有则通过 `UserService` 的 `findloginTicket` 方法查询用户
    ID，再通过用户 ID 查询用户。最后将用户放入 `hostHolder` 中。
- 在 `postHandle` 方法中通过 `hostHolder` 的 `get` 方法获取用户，并将其存入视图中。
- 在 `afterCompletion` 方法中清除 `hostHolder` 中存放的用户信息。
- 创建 `WebMvcConfig` 配置类，实现 `WebMvcConfigurer`接口，配置 `LoginTicketInterceptor`，拦截除了静态资源之外的所有路径。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201418.png)

因为我们在前端页面并不知道我们是否已经登录，所以我们需要导入拦截器显示已经登录的消息，在拦截器中查看当前浏览器是否有`cookie`，如果没有则不用在本次页面请求中加入`user`
,如果有，则判断本次登录的凭证是否还存活，如果还存活，则将此`cookie`的`user`存储到`model`中，并在前端中展示

1. 接收浏览器传来的用户名、密码、验证码、是否记住我，这里还要用到`model`、`session`和`response`
2. 首先判断验证码是否正确，从`session`中取出登录页面生成的验证码，返回类型是对象，强制转换为`String`。不正确就返回验证码错误的消息，并返回登录页面
3. 首先根据是否记住我，选择登录凭证过期时间，然后调用`login`，使用`map`接收返回的信息
4. `map`里有`ticket`说明登录成功，将`ticket`存入`cookie`通过响应发送给浏览器，并重定向到首页
5. 登录失败就返回相应错误消息，跳转到登录页

用户登录后拿到`ticket`存到`cookie`，之后每次请求都带上`ticket`，拦截器拦截请求，用`ticket`查询`login_ticket`，再查询`user`，将`user`添加到`model`
中，模板引擎根据有无`user`及`user`的值去渲染页面。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407234132.png)

我们要从`cookie`中拿到`ticket`的值，先封装一个`cookieUtil`。

比较简单，直接写静态方法，不交给容器管理。传入`request`和我们想要的`cookie`的值。首先判断空值的情况，然后遍历`cookie`，找到我们想要的那个。

浏览器同时处理多个用户请求，对每个用户的`user`对象要做一个存储，可以使用`session`，但是`session`依赖`servlet api`
，我们想要在方法里随用随取，anywhere！为了解决这个问题，我们就要采取一种新的方法来存储用户信息——`ThreadLocal`。

`ThreadLocal`，顾名思义，就是本地线程，可是这个名字实在容易让人误解，因为其实它是本地线程局部变量的意思，首先我们要知道，我们每个请求都会对应一个线程，这个`ThreadLocal`
就是这个线程使用过程中的一个变量，该变量为其所属线程所有，各个线程互不影响。

我们封装一个工具`HostHolder`，用来持有用户信息，代替`session`对象。主要有添加查询和删除方法。

在`Interceptor`包下新建`LoginTicketInterceptor`。首先重写`preHandler`方法，利用前面封装的`cookieUtil`工具得到`ticket`，查到用户，并用`hostHolder`
持有用户。然后重写`postHandle`方法，在`modelAndView`上加上`user`。请求结束后，清理掉不需要的用户数据。

### 上传头像

- 在 `UserService` 新增 `updateHeader` 方法，更改指定用户的头像。

- 创建 `UserController`
  - 新增 `getSettingPage` 方法访问账户设置 setting.html ，并在 index.html 的账号设置按钮关联该链接。
  - 新增 `uploadHeader` 方法更新用户头像，如果上传出现错误将错误信息存在 Model 对象中。
  - 如果没有错误，生成一个文件对象 `dest`，利用 `MultipartFile` 接口的 `transferTo` 方法将用户上传文件导入 `dest`，并从 `hostHolder` 中取出用户，更新用户的头像路径。
- 新增 `getHeader` 方法获取用户头像，利用文件输入流读取图片数据，利用 `HttpServletResponse` 的字节输出流再进行输出。
- 调整 `setting.html` 的 `form` 表单， `method="post"，enctype="multipart/form-data"`，并设置提交路径。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201434.png)

这里用到的是`Spring MVC`的`multipartFile`，头像的存储和获取直接在`controller`层操作。新建一个`UserController`。

上传头像的方法，这里从容器获取两个对象，一个是`MultiparFile`，也就是从浏览器传过来的头像文件，一个是`model`，用于模型返回信息。

首先对空值进行处理，然后用`substring`分割出文件后缀，`png`或者`jpg`等等。如果没有后缀就提示文件格式不正确。对用户上传的图片重命名，用之前写的生成`uuid`的方法加上分割出来的文件后缀。

再在我们指定的文件存放位置新建一个文件，文件名使用生成的名字，并记录异常，将异常向上抛出，用于之后的处理。

然后从`hostHolder`里获取当前用户，更新头像路径。

头像获取，从访问路径中截取头像文件名，从容器获取`response`对象，用服务器存放的全路径覆盖文件名，使用文件输入流和`response`的输出流，建一个1024字节的缓冲区，从本地头像文件读取，输出到`response`里。

### 检查登录状态

- 利用拦截器，实现只处理带有自定义注解的方法，防止用户在未登录情况下通过 `url` 访问没有权限的页面。
- 创建 `@LoginRequired` 自定义注解，作用范围在方法上，有效期为运行时。
- 在 `UserController` 中需要在登录状态下调用的方法，访问设置页面、修改密码、上传头像等加上自定义注解。
- 创建 `LoginRequiredInterceptor` 拦截器，在 `preHandle` 方法中判断方法是否加了 `@LoginRequired` 注解，如果加了注解并且此时从 `hostHolder` 中获取不到用户则拒绝访问。
- 在 `WebMvcConfig` 配置类配置 `LoginRequiredInterceptor`，拦截除了静态资源之外的所有路径。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201446.png)

我们在前面开发的账号设置，并不能让每个用户都登陆，如果没登录的话就不能登录，那我们该如何实现这个功能呢，通过注解与拦截器，我们实现拦截未登录用户。怎么实现的呢，如果登录了的话，我们在本次请求中`hostHolder` 保留有`User`
，我们在拦截器中判断是否有`User`就可以判断是否已经登录。

新建一个`annotation`包，包下新建一个`annotation`类。定义好注解后，在需要登录才能访问的方法上面加上注解，目前主要就是设置界面和上传头像需要登录。

使用注解标记需要处理的方法后，定义拦截器进行统一处理。这里只对响应前进行处理，也就是只重写`preHandle`。

首先判断拦截对象是不是一个方法，如果是的话讲`Object`对象转型成`HandlerMethod`对象。获取拦截的方法，查找该方法有没有我们写的`@LoginRequired`注解。有的话看`hostHolder`里有没有`user`
，如果有注解没`user`就重定向到登录页面，这里不是在`controller`层，所以需要用`respons`重定向。

## 开发核心功能

### 敏感词过滤

利用字典树数据结构解决。

- 创建 `SensitiveFilter` 类
  - 创建静态内部类 `TrieNode` ，通过 `boolean` 类型的结束符判断是否匹配到关键字尾部。
  - 利用 `@PostConstruct` 注解，在构造方法执行后初始化字典树。
  - 添加 `filter` 方法，利用双指针进行匹配，过滤敏感词

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200756.png)

### 发布帖子

- 引入 fastjson 依赖，在 `CommunityUtil` 中新增 `getJSONString` 方法封装 JSON 信息。
- 在 `DisscussPostMapper` 接口新增 `insertDiscussPost` 方法，并在 `DisscusspostMapper.xml` 配置 `insert` 语句。
- 在 `DiscussPostService` 新增 `addDiscussPost` 方法调用 `DisscussPostMapper` 的 `insertDiscussPost` 方法，其中需要进行对标题内容和发帖内容进行 HTML
  转义以及过滤敏感词。
- 创建 `DiscussPostController` 类，新增 `addDiscussPost` 方法，调用 `DiscussPostService` 的 `addDiscussPost` 方法发帖。
- 在 `index.html` 中为发帖按钮绑定函数，利用 Ajax 向 `DiscussPostController` 的 `addDiscussPost` 方法发送 `POST` 请求。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200822.png)

前端判断用户是否已经登录，若无登录，发布帖子的功能按钮便不会展现在前端，因为我们不想一次刷新就把整个页面都刷新，所以我们导入了fastJson这个包，前端页面只用js代码(jquery代码)
异步请求就可以实现帖子的发送，把前端的内容和标题发送给`controller`,在`controller`调用`service`，存入数据库。

### 显示帖子内容

- 在 `DisscussPostMapper` 接口新增 `selectDiscussPostById` 方法，在 `DisscusspostMapper.xml` 配置 `select` 语句。
- 在 `DiscussPostService` 新增 `findDiscussPostById` 方法调用 `DisscussPostMapper` 的 `selectDiscussPostById` 方法。
- 在 `DiscussPostController` 新增 `getDiscussPost` 方法，调用 `DiscussPostService` 的 `findDiscussPostById`
  方法查询帖子内容，将 `DiscussPost` 对象和 `User` 对象（通过 `userId` 查询，不在 DAO 层关联查询）数据存放到 `Model` 对象，返回模板 `discuss-detail`。
- 在 `discuss-detail.html` 取出 `Model` 对象存放的数据绑定到对应组件显示。

### 显示评论(`comment` 表)

`user_id`对应的是发评论的用户，`entity_type`是指评论的类型，目前我们打算开发论坛部分，那么就有两种类型，对帖子的评论和对评论的评论，为了方便区分，对评论的评论我们成为回复，`entity_id`对应回复的实体的`id`
，`target_id`也就是回复的对象，这个主要是在回复的时候需要显示回复的谁

- 评论需要分页，所以传入`page`对象。
- 对`page`对象进行配置，一页显示5条，`page`的路径和总的评论数
- 首先用上面写的方法查询评论，放到`list`里，然后还需要进行一些处理。查询到的评论里只有`user_id`，没有用户名，同时评论下还有回复。
- `VO`代表显示对象，用来显示在页面上的对象。
- 整个逻辑就是查出当前帖子下的所有评论，遍历所有评论，处理用户名等信息，查询评论下的回复，遍历每个回复，处理用户名等信息。

- 创建 `comment` 表对应的实体类 `Comment`。
- 创建 `CommentMapper` 接口
  - 新增 `selectCommentsByEntity` 方法，根据实体查询一页的评论数据。
  - 新增 `selectCountByEntity` 方法，根据实体查询评论的数量。
- 在 `CommentMapper.xml` 配置 `select` 语句。
- 创建 `CommentService` 类
  - 新增 `findCommentByEntity` 方法，调用 `CommentMapper` 的 `selectCommentByEntity` 方法。
  - 新增 `findCommentCount` 方法，调用 `CommentMapper` 的 `selectCountByEntity` 方法。
- 在 `DiscussPostController` 的 `getDiscussPost` 方法中增加查询帖子评论和回复的逻辑，将结果存储在 `Model` 对象。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200856.png)

### 添加评论

使用了事务：

- 在 `CommentMapper` 接口新增 `insertComment` 方法，添加评论数据，在 `CommentMapper` 配置对应 sql。
- 在 `DiscussPostMapper` 接口新增 `updateCommentCount` 方法，增加评论数量，在 `DiscusspostMapper` 配置对应 sql。
- 在 `DiscussPostService` 类新增 `updateCommentCount` 方法，调用 `DiscussPostMapper` 的 `updateCommentCount` 方法。
- 在 `CommentService` 类新增 `addComment` 方法，调用 `CommentMapper` 的 `insertComment` 新增评论，并调用 `DiscussPostService`
  的 `updateCommentCount` 更新评论数量，使用 `@Transactional` 注解保证事务。
- 创建 `CommentController` 类，新增 `addComment` 方法，从 `hostHolder` 获取用户信息，然后调用 `CommentService` 的 `addComment` 方法添加评论。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201211.png)

添加评论的功能也是比较基础的，按照数据层业务层和表现层进行开发，比较特别的就是会用到前面提到的事务管理。

为了效率，在帖子的字段里设计了一个评论数量，那么我们添加评论的时候就要同时更新评论数量。

### 显示私信列表(`message`表)

- 创建对应 `message` 表的实体类 `Message`。
- 创建 `MessageMapper` 接口，增加查询会话列表、会话数量、私信列表、私信数量、未读私信数量等方法，在 `MessageMapper.xml` 中配置对应的 sql。
- 创建 `MessageService`，调用 `MessageMapper` 中的方法。
- 创建 `MessgaeController`
  - 新增 `getLetterList` 方法，将会话列表信息存储到 `Model` 对象，返回 `letter` 视图。
- 新增 `getLetterDetail` 方法，将每个会话具体的私信信息存储到 `Model` 对象，返回 `letter-datail` 视图。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201223.png)

首先看一下数据库的设计，私信相当于一个对话功能，那么两个人就组成一个对话，这段对话里有A发给B的消息，有B发给A的消息，那么我们把发送者和接收者的id拼接到一起形成一个会话`id`，把`id`
小的拼接在前面。还有一种私信是系统通知，那么只需要把`from_id`指定一个固定的值，这里指定为1。

数据层新建`MessageMapper`，定义好方法。私信列表需要显示的内容：

- 显示当前用户的所有会话，那么每个会话只显示最新的一条消息就行了
- 还需要显示当前用户一共有多少会话
- 每个会话包含的所有私信
- 每个会话包含的所有私信数量
- 还有每个会话未读的私信数量

表现层要加载私信列表，从`hostholder`获取当前用户。将会话和私信内容，未读数量等封装到`List<map<>>`里。

然后继续开发会话详情功能。当前端点击会话列表中的某一个时，传入会话`id`，查询该会话`id`下的所有私信。页面上还需要显示发送私信的人，拆解`conversationid`，判断哪个是收信人。

### 发送私信

- 在 `MessageMapper`
  - 新增 `insertMessage` 方法插入私信记录，在 `MessageMapper.xml` 配置 `insert` 语句。
  - 新增 `updateMessage` 方法修改私信状态，在 `MessageMapper.xml` 配置 `update` 语句，利用 `foreach` 动态 sql。
- 在 `MessageService`
  - 新增 `addMessage` 发送私信方法，过滤敏感词后，调用 `MessageMapper` 的 `insertMessage` 。
  - 新增 `readMessage` 方法读取信息，调用`MessageMapper` 的 `updateMessage` 更新私信的状态为 1。

- 在 `MessageController`

  - 新增 `getLetterIds` 方法，将私信集合中未读私信的 `id` 添加到 `List` 集合并返回，在 `getLetterDetail` 方法调用该方法设置已读。
  - 新增 `sendLetter` 发送私信方法，设置私信信息后调用 `MessageService` 的 `addMessage` 发送。

私信某人说明两个人建立一个会话，每个人都有一个会话列表。数据库里面有个`message`表就是用来存储私信相关的信息。里面有几个重要的字段，一个是`from_id`这条私信发起者 ， 一个是`to_id`这条私信接收者。会话`id`
由这两个`id`拼接而成。查看私信就跟据会话`id`获取两个人的信息。未读消息由数据库`status`字段标记。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201234.png)

数据层首先在`MessageMapper`里新增两个方法，一个新增消息，一个修改消息状态的方法。

表现层接收前端传来的用户名和内容，创建`message`对象，补充相关内容，拼接`conversationId`的时候把小的拼在前面。

然后实现把未读消息改成已读。在之前写的加载消息列表的方法里补充一下。首先写一个方法获取所有未读消息的`id`。然后在`getLetterDetail`方法里加上设置已读的方法。

### 统一异常处理

- 在 `HomeController` 中增加 `getErrorPage` 方法，返回错误页面。
- 创建 `ExceptionAdvice` 类
  - 加上 `@ControllerAdvice` 注解，表示该类是 `Controller` 的全局配置类。
  - 创建 `handleException` 方法，加上 `@ExceptionHandler` 注解，该方法在 `Controller` 出现异常后调用，处理捕获异常。如果是异步请求返回一个 JSON
    数据，否则重定向至 `HomeController` 的 `getErrorPage` 方法。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201254.png)

- 首先使用`@ControllerAdvice`注解修饰类，指定范围是`controller`下的类
- 声明日志，然后写异常处理的方法，我们直接捕获所有异常
- 将异常写入日志，然后判断当前请求是需要返回页面还是数据，从请求中获取请求头参数`x-requested-with`，如果参数等于`XMLHttpRequest`，那么请求是一个异步请求，返回一个`json`
  字符，否则重定向到`error`页面。

### 统一日志处理

- 在 `pom.xml` 引入 `aspectj` 的依赖。
- 创建 `ServiceLogAspect` 类，添加 `@Aspect` 切面注解，配置切入点表达式，拦截所有 `service` 包下的方法，利用 `@Before` 记录日志。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200647.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200706.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200718.png)

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407200730.png)

## Redis

### 点赞

- 创建 `RedisKeyUtil` 工具类
  - 定义分隔符 : 以及实体获得赞的 `key` 前缀常量 `like:entity`。
  - 新增 `getEntityLikeKey(int entityType,int entityId)` 方法，通过实体类型和实体 `id` 生成对应实体获得赞的 `key`。
- 创建业务层的 `LikeService` 类
  - 注入 `RedisTemplate` 实例。
  - 新增 `like` 点赞方法，首先通过 `RedisKeyUtil` 工具类的 `getEntityLikeKey` 方法获得实体点赞的 `key`，然后通过 `RedisTemplate` 对象对 `set`
    集合的 `isMember` 方法查询 `userId` 是否存在于对应 `key` 的 `set` 集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。
  - 新增 `findEntityLikeCount` 方法查询实体的点赞数量，通过调用 `set` 集合的 `size` 方法查询元素个数。
- 新增 `findEntityLikeStatus` 方法查询某用户对某实体的点赞状态，逻辑如 `like` 方法，通过 `set` 集合的 `isMember` 方法实现。

- 创建表现层的 `LikeController` 类
  - 注入 `LikeService` 和 `HostHolder` 实例。
  - 新增 `like` 点赞方法，调用业务层的 `like` 方法进行点赞、调用 `findEntityLikeCount` 和 `findEntityLikeStatus` 查询点赞数量和点赞状态，封装到 map
    集合，然后通过工具类封装成 JSON 数据返回。

- （更新首页帖子点赞数量）在表现层的 `HomeController` 类
  - 注入 `LikeService` 实例。
  - 在 `getIndexPage` 方法在通过 `LikeService` 类的方法获得点赞数量，存储到 map 集合。

根据实体`id`和实体类型者两个参数确定点赞的目标，使用`redis`的`set`数据类型，`redis`根据实体`id`与实体类型为`key`，存储`value`是点赞用户`id`
，值得注意的是，当对一个实体点赞时候。该实体的拥有者也会获得一个赞。拥有者`id`为`key`，`value`加1（这里用了`redis`事务）。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201527.png)

### 收到的赞

对点赞功能进行重构

- 在 `RedisUnitl` 工具类
  - 新增用户获得赞 `key` 的前缀常量 `like:user`
  - 新增 `getUserLikeKey(int userId)` 方法，通过用户 `id` 生成对应用户获得赞的 `key`。

- 在 `LikeService` 中
  - 重构 `like` 方法，在参数列表中加入 `entityUserId` 表示被点赞用户的 `id`，用来更新用户的被点赞数量。
    - 通过 `RedisTemplate` 对象的 `execute` 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 `isMember` 方法查询用户的点赞状态，之后通过 `mutli` 方法开启事务。
    - 当用户已点赞时，调用 `remove` 方法将当前用户从点赞用户的集合中移除，调用 `decrement` 方法将被点赞用户的被点赞数减 1；当用户未点赞时，调用 `add`
      方法将当前用户添加到点赞用户的集合，调用 `increment` 方法将被点赞用户的被点赞数加 1。

  - 增加 `findUserLikeCount` 方法，以用户 `id` 作为 `key`，调用 `get` 方法查询用户所获得的点赞数。
- 在 `LikeController` 中给 `like` 方法增加 `entityUserId` 参数即可。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201543.png)

### 关注

- 在 `RedisUnitl` 工具类
  - 新增用户关注实体（帖子、评论、用户等）和粉丝（用户）的前缀常量 `followee` 和 `follower`
  - 新增 `getFolloweeKey(int userId, int entityType)` 方法，通过用户 `id` 和实体类型生成用户关注实体的`key`。
  - 新增 `getFollowerKey(int entityType, int entityId)` 方法，通过实体类型和实体 `id` 生成实体用户粉丝的 `key`。

- 创建业务层的 `FollowService` 类
  - 新增 `follow` 方法，当用户关注某实体时，
    - 调用 `add` 方法将当前实体 `id` 和时间作为 `value` 和 `score`加入用户的关注集合。
    - 调用 `add` 方法将当前用户 `id` 和时间作为 `value` 和 `score` 加入实体的粉丝集合。
  - 新增 `unfollow` 方法，当用户取消关注某实体时，
    - 调用 `remove` 方法将当前实体从用户的关注集合移除。
    - 调用 `remove` 方法将用户从实体的粉丝集合移除。

关注也类似，某个人关注一个人，这个人多一个关注另一个人多一个粉丝，因为用的是有序集合，第二个值`score`存储当前时间，关注列表那里根据时间进行顺序排序。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201554.png)

### 个人主页

- 在业务层的 `FollowService` 类
  - 新增 `findFolloweeCount` 方法，调用 `zset` 的 `zcard` 方法查询某用户关注的实体数量。
  - 新增 `findFollowerCount` 方法，调用 `zset` 的 `zcard` 方法查询某实体的粉丝数量。
  - 新增 `hasFollowed` 方法，根据 `zset` 的 `zscore` 方法返回值查询当前用户是否关注某实体。
- 在 `UserController` 中新增 `getProfilePage` 方法获取个人主页。
  - 调用 `LikeService` 的 `findUserLikeCount` 查询用户获赞数，并添加到 `Model` 中。
  - 调用 `FollowService` 的`findFolloweeCount`、`findFollowerCount` 、`hasFollowed` 方法分别查询关注数量、粉丝数量、用户是否关注三项信息并添加到 `Model`
    对象中存储。

### 关注列表和粉丝列表

- 在业务层的 `FollowService` 类

  - 新增 `findFollowees` 方法，查询用户关注列表，主要通过 `zset` 的 `reverseRange` 获取 `value` 即关注用户的 `userId`，再查询出其 `user`，之后通过 `score`
    获取关注时间，存入 map 集合，将 map 添加到 list 列表返回。
  - 新增 `findFollowers` 方法，查询用户粉丝列表，主要通过 `zset` 的 `reverseRange` 获取 `value` 即粉丝的 `userId`，再查询出其 `user`，之后通过 `score`
    获取关注时间，存入 map 集合，将 map 添加到 `list` 列表返回。
- 在表现层的 `FollowController` 类
  - 新增 `getFollowees` 方法，获取关注列表，存入 `Model` 对象。
  - 新增 `getFollowers` 方法，获取粉丝列表，存入 `Model` 对象。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201604.png)

### 优化登录模块

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407201619.png)

#### 存储验证码

- 在 `RedisUntil` 工具类
  - 新增验证码前缀常量 `kaptcha`
  - 新增 `getKaptchaKey` 方法，通过一个用户凭证（由于未登录，利用 `cookie` 实现）获得对应验证码的 `key` 值（利用 `string` 存储验证码）。
- 在表现层的 `LoginController` 类
  - 重构 `getKaptcha` 方法，将验证码存入 `redis`，`key` 值是当前随机生成的一个字符串，同时将该字符串存入 `cookie`。
  - 重构 `login` 方法，从 `cookie` 中获得随机字符串，生成验证码的 `key` 值，然后获取对应的 `value` 值即验证码。

#### 存储登录凭证

- 在 `RedisUntil` 工具类
  - 新增登录凭证前缀常量 `ticket`
  - 新增 `getTicketKey` 方法，通过字符串获得登录凭证的对应 `key` 值（利用 `string` 存储）。
- 在业务层的 `UserService` 类
  - 重构 `login` 方法，将登录凭证存入 `redis` 中。
  - 重构 `logout` 方法，先从 `redis` 中获取登录凭证对象，将状态设为无效再重新存储进 `redis`。
  - 重构 `findLoginTicket` 方法，根据 `ticket` 字符串获得对应登录凭证的 `key`，然后从 `redis` 查询登录凭证。

#### 缓存用户信息

- 在 `RedisUntil` 工具类
  - 新增用户前缀常量 `user`
  - 新增 `getUserKey` 方法，通过用户 `id` 获得用户的对应 `key` 值（利用 `string` 存储）。
- 在业务层的 `UserService` 类
  - 新增 `getCache`，从缓存获取用户信息。
  - 新增 `initCache`，从 MySQL 查询用户信息并存入 `redis`。
  - 新增 `clearCache`，用户信息变更（更新头像，激活）时清除缓存。
  - 重构 `findUserById` 方法，首先调用 `getCache`从缓存获取用户信息，如果获取为 `null` 则调用 `initCache`。

### 热帖排行

## Kafka

### 发送系统通知

在 `CommunityConstant` 接口中新增三个常量，代表三个主题：评论、点赞、关注。

创建 `Event` 类，封装事件对象，包括主题、用户 `id`、实体类型、实体 `id`、实体用户 `id` 以及一个 map 集合存放其它信息。

通知这一部分，关于何时通知，当别人评论你的帖子，别人回复你的评论，别人点赞你的实体（帖子评论），别人关注了你的时候。因为用的是同一张表，这时候`from_id`变为1，`conversation_id`为发起通知类型。`content`
字段不在存储字符串，而是存放json字符串包含用户`id`、实体`id`、实体类型、帖子`id`。用来表明是什么类型的信息、发生在什么时候。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407202055.png)

#### 触发事件

创建 `EventProducer` 事件生产者，新增 `fireEvent(Event event)` 方法，通过 `Event` 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 `KafkaTemplate`
实例的 `send` 方法发送。

在 `CommentController`、`LikeControler`、`FollowController` 中注入 `EventProducer` 实例，分别重构 `addComment` 方法、`like` 方法、`follow`
方法，封装 `Event` 对象，然后调用 `EventProducer` 的`fireEvent` 方法发布通知。

#### 消费事件

创建 `EventConsumer` 事件消费者，消费者是被动触发的。

- 注入 `MessageService` 实例。
- 增加 `handleCommentMessage(ConsumerRecord record)` 方法，通过 `@KafkaListener` 注解，`topic` 包括了评论、点赞和关注。从 `recored`
  中获取信息，封装成 `Message` 对象然后调用 `addMessage` 方法插入数据库。

### 显示系统通知

#### 通知列表

在 `MessageMapper` 接口中

- 新增 `selectLatestNotice(int userId, String topic)` 方法，查询某主题最新的通知。
- 新增 `selectNoticeCount(int userId, String topic)` 方法，查询某主题通知的数量。
- 新增 `selectNoticeUnreadCount(int userId, String topic)` 方法，查询未读通知的数量。
- 在 `MessageMapper.xml` 配置三个方法的 sql 语句，其中查询未读通知时使用 `if` 动态语句，如果没有传入 `topic` 就查询未读总量。

- 在业务层的 `MessageService` 中
  - 新增 `findLatestNotice` 方法，调用 `selectLatestNotice` 方法查询最新通知。
  - 新增 `findNoticeCount` 方法，调用 `selectNoticeCount` 方法查询某主题通知的数量。
  - 新增 `findNoticeUnreadCount` 方法，调用 `selectNoticeUnreadCount` 方法查询未读通知的数量。

- 在表现层的 `MessageController` 中新增 `getNoticeList` 方法，获取通知列表
  - 调用业务层 `MessageService` 的方法查询评论、点赞、关注的通知，将其封装在一个 `HashMap` 集合中然后添加到 `Model` 对象里。
  - 调用业务层 `MessageService` 的方法查询私信和通知的总未读数量，添加到 `Model` 对象里。
  - 返回 `notice.html` 页面。

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407202113.png)

#### 显示通知详情

在 `MessageMapper` 接口新增 `selectNotices` 方法，查询某个主题的通知列表，在 `MessageMapper.xml` 配置 SQL。

- 在业务层的 `MessageService` 中新增 `findNotices` 方法，调用 `selectNotices` 方法。
- 在表现层的 `MessageController` 中新增 `getNoticeDetail` 方法
  - 调用 `findNotices` 方法获取通知列表详情，封装到 `List` 集合并存入 `Model` 对象。
  - 从通知集合中获取 `id` 集合，调用 `readMessage` 方法将消息设为已读。
  - 返回 `notice-detail.html` 页面。

#### 显示未读通知总数

- 创建 `MessageInterceptor` 拦截器
  - 注入 `MessageService` 实例和 `HostHolder` 实例。
  - 重写 `postHandle` 方法，查询私信和通知的未读数量和，然后添加到 `ModelAndView` 对象。
- 在 `WebConfig` 中注入 `MessageInterceptor` 实例，并在 `addInterceptors`ƒ 方法中添加该拦截器。

## Elasticsearch

### 开发社区搜索功能

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407202200.png)

## 优化网站的性能

- 本地缓存
  - 将数据缓存在应用服务器上，性能最好，如Guava，Caffeine
- 分布式缓存
  - 将数据缓存在NoSQL数据库上，跨服务器，如Redis
- 多级缓存
  - 一级缓存(本地缓存) -> 二级缓存(分布式缓存) ->DB
  - 避免缓存雪崩(缓存失效，大量请求直达DB)，提高系统可用性

## 项目发布

客户端的请求一般由Nginx反向代理接收，而Nginx服务器至少部署两台，保证在主服务器挂掉的情况下，也有服务器能够进行反向代理

而网站的静态资源一般放在CDN

一般业务服务器会部署多台，

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20210407212640.png)

## 相关问题

- 什么是Spring框架？

  有很多模块组成，利用这些模块可以方便开发工作。这些模块是：核心容器（spring core)/数据访问和集成(Spring JDBC)/Web(Spring Web/MVC)/AOP(Spring Aop)/消息模块/测试模块(
  Spring Test)等。

- 对Spring IoC的理解

IoC的意思是控制反转，是一种设计思想，把需要在程序中手动创建对象的控制权交给了Spring框架。IoC的载体是IoC容器，本质是一个工厂，数据结构上来看是一个Map，用来存放着各种对象。当我们创建一个对象时，只需要配置好配置文件/注解，而不用担心对象是怎么被创建出来的。

IoC的优点：降低耦合，对象被容器管理需要两份数据：你的对象定义 + 配置文件，对象间的关系体现在配置文件，不会直接产生耦合。

- 什么是DAO

data access object，存放数据库访问对象。

- Spring中关于Bean的注解

四种常见Bean:@Controller @Repository @Service @Component一般来说Bean只会被容器初始化一次，@PostConstruct：初始化前调用 @PreDestroy：销毁之前

- 如何使用Bean

bean通过容器管理，不需要我们实例化，如果要使用某个bean，使用依赖注入 @Autowired

- Spring MVC是什么，是怎样的工作流程

服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)
，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。

1. 客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)
2. DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler。
3. 查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理
4. HandlerAdapter根据Handler来调用真正的Controller
5. Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View
6. ViewResolver根据逻辑view找到实际view
7. DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者

C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。

M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。

V - View：视图。返回给客户看的结果。

- 什么是SSM框架？

包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）

- 怎么实现注册功能的？

根据请求来拆解功能

1. 打开注册网页
2. 把注册的信息发送给服务器（点注册）
3. 把激活邮件发送给邮箱
4. 利用激活链接打开网页

每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层

- 什么是`Interceptor`，在项目的哪里使用到了`Interceptor`?

Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查`request`中的`login_ticket`，把找到的`user`
信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）

- 使用什么技术生成验证码

使用Kaptcha包，可随机生成字符和图片。

- 如何检查登陆状态

加拦截器注解。

- 如何实现敏感词过滤

使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。

- 什么是Ajax，应用在项目哪些地方？

ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。

项目中：帖子发布成功/失败的提示，使用到ajax

- 什么是事务，事务的四大特性。

定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。

ACID：

A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。 C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。 I
：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。 D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。

- 在并发环境下，并发事务会出现哪些问题？

脏读：事务A读到了事务B修改但未提交的数据。

丢失修改：事务A和事务B同时读取了某一数据，并进行减１，此数据最终只会减一。

不可重复读：事务A多次读取某数据时，发现前后不一致（被事务B修改了）

幻读：和不可重复读类似，事务A读取到几行数据，事务B此时插入数据，随后的查询中，事务A发现了一些原本不存在的数据。（不是读取）

- 介绍SQL的四个隔离级别
  `READ-UNCOMMITED`(读取未提交）:会出现脏读，不可重复读，幻读。

`READ-COMMITED`:会出现不可重复读，幻读

`REPETABLE-READ`:会出现幻读

`SERIALIZABLE`:都不会出现

- 怎么利用Spring实现事务管理

Spring管理事务忽略了底层数据库的结构，非常方便。有两种方式：注解（类型，传播方式）/编程式事务（override)。

- 是怎样实现统一捕获异常的？

在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层(`controller`)统一处理错误即可。

方法：在`controller`中加上`advice`包，并通过注解`@ControllerAdvice`和`@ExceptionHandler`，统一捕获异常。

- 是怎样实现统一记录日志的？

使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。
AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。
SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。

- 什么是`Redis`，`Redis`有哪些优点？

概念：redis是一个非关系型数据库，数据存储在内存中，读写速度快。可以存储键和五种不同类型值的映射。只能以字符串为键，值支持：字符串，列表，无序集合，有序集合，hash散列表。
优点：由于数据存储在内存中，读写速度非常快，满足高性能，高并发的系统要求。与Java原生的map/guava相比，支持分布式缓存。与memcached相比，支持更丰富的数据类型，且支持数据持久化。

- Redis分布式集群架构

典型的分片+复制

- 怎么往Spring框架中配置redis，介绍常见的redis操作

如何配置：

1. 导入jar包
2. 配置端口，以及配置类`redisTemplate`（注入连接工厂/设置序列化方式（json））

常见操作:

`Value`类型：`redisTemplate.opsForValue().set(redisKey, 1)`，`redisTemplate.opsForValue().get(redisKey)`
， `redisTemplate.opsForValue().increment(redisKey)`，

`Hash`类型：`redisTemplate.opsForHash().put(redisKey, “id”, 1)`， 还有`get`等操作

`List`类型：`redisTemplate.opsForList().leftPush(redisKey, 101)`， 还有`size`, `index`, `range`， `leftPop`等操作

`Set`类型：`add`,`size`,`pop`,`members`等操作

`Zset`类型：`redisTemplate.opsForZSet().add(redisKey, “Linda”, 92)`, 有`socre`，`rank`，`reverseRank`，`range`等操作

操作`key`：可以`delete`，以及设置过期时间

同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）

为什么不包含查询：`redis`事务就是一系列命令的批量操作，批量操作在发送 `EXEC` 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。

- 怎样存储的点赞/关注/缓存用户数据

点赞使用`set`类型存储，`key`为点赞对象，`set`中保存点赞人的ID

关注使用`zSet`类型存储，`key`为被关注者，`set`保存关注者以及关注时间为`score`

缓存用户数据使用`Value`类型，`key`为用`userID`得到的`key`，`value`为`user`对象（设置过期时间，且数据修改时需要清除缓存）

- 什么是消息队列

消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：

1. 解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。
2. 异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。
3. 限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。

- 消息队列作为信息传递的中间件，需要注意哪些问题？

1. 高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式/集群的现成支持）
2. 数据持久化：防止数据丢失
3. 如何取数据：消息队列主动通知或者消费者轮询。

- Java中的`blockingqueue`，可以提供线程间的消息队列

BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）`Blocking Queue`构建了一个桥梁，能够解决生产速度/消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。

- 什么是`Kafka`，有哪些功能和应用场景？

`Kafka`为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。

`Kafka`主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。

- Kafka的消息模型，以及常见术语

消息模型：发布-订阅模型，消费者订阅了某一主题（`topic`）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。

`Topic`：主题，类似于文件夹，用来存放不同的数据。

`Partition`：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。

`Offset`：消息在`Partition`中的存放位置。

`Broker`：可以理解为`kafka`集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着`topic1`的`leader`， `topic2`的`follower`等等。

- 在项目哪里用到了`Kafka`

当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了`Kafka`，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的`Controller`
使用，产生消息。而消费者负责消息（`message`）到来时，把消息存到数据库内。

- 什么是`Caffeine`，如何缓存，项目应用

概念：`Caffeine` 是一个基于Java 8的高性能本地缓存框架

初始化cache：缓存保存的对象，使用`Caffeine.newBuilder()`创建，创建时设置缓存大小，过期时间，缓存未命中时的加载方式。

为什么只缓存热度帖子？不会经常变。
